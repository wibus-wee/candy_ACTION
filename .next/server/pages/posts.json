{"pageProps":{"posts":[{"title":"一起入手TypeScript（四）","slug":"typescript-4","created":"2021-01-02T16:01:41.008Z","modified":"2021-01-03T07:42:20.098Z","content":"\n\n## 10 TypeScript 类的概念和使用\n\n`TypeScript` 中类的概念和` ES6 `中原生类的概念大部分相同，但是也额外增加了一些新的特性。我在这里会完全从一个新手的角度，讲解类的各项知识点。\n\n### 10.1 类的基本使用\n\n新建一个文件，叫做`demo10.ts`,然后定义一个最简单的`Lady`类,这里要使用关键字`class`,类里边有姓名属性和一个得到姓名的方法\n```ts\nclass Lady {\n    content = \"Hi，帅哥\";\n    sayHello() {\n      return this.content;\n    }\n}\n  \nconst goddess = new Lady();\nconsole.log(goddess.sayHello());\n// ts-node demo10.ts\n//result：Hi，帅哥\n```\n\n> 代码下面的注释的意思是：运行ts-node demo10.ts命令，得到的结果是：Hi，帅哥\n\n这是一个最简单的类了，如果你有些编程经验，对这个一定很熟悉\n\n### 10.2 类的继承\n\nTypeScrip 的继承和ES6中的继承是一样的。关键字也是`extends`,比如我们这里新建一个`xiaoJieJie`的类，然后继承自`Lady`类，在`XiaoJieJie`类里写一个新的方法，叫做`sayLove`,具体代码如下。\n\n```ts\nclass xiaoJieJie extends Lady{\n    sayLove(){\n        return \"I love you.\";\n    }\n}\n\nconst Wibus = new xiaoJieJie();\nconsole.log(Wibus.sayHello());\nconsole.log(Wibus.sayLove());\n// ts-node demo10.ts\n// result: Hi，帅哥 I love you.\n```\n类写好以后，我们声明的对象是`xiaoJieJie`这个类，我们同时执行`sayHello()`和`sayLove()`都是可以执行到的，这说明继承起作用了\n\n### 10.3 类的重写\n\n讲了继承，那就必须继续讲讲重写，重写就是子类可以重新编写父类里边的代码。现在我们在`XiaoJieJies`这个类里重写父类的`sayHello()`方法\n\n```ts\nclass XiaoJieJies extends Lady {\n    sayLove(){\n        return \"I love you.\";\n    }\n    sayHello() {\n        return \"Hi, honey!\";\n      }\n}\n\nconst wibus = new XiaoJieJies();\nconsole.log(wibus.sayHello());\nconsole.log(wibus.sayLove());\n// ts-node demo10.ts\n// result: Hi, honey! I love you.\n```\n\n### 10.4 super 关键字的使用\n\n比如我们还是想使用`Lady`类中说的话，但是在后面，加上`你好`两个字就可以了。这时候就可以使用`super`关键字，它代表父类中的方法\n\n```ts\nclass Xiaojiejie extends Lady {\n    sayLove() {\n        return \"I love you!\";\n      }\n      sayHello() {\n        return super.sayHello() + \".你好！\";\n      }\n}\n\nconst goddesss = new Xiaojiejie();\nconsole.log(goddesss.sayHello());\nconsole.log(goddesss.sayLove());\n// ts-node demo10.ts\n// result: Hi，帅哥.你好！I love you!\n```\n\n那么整个下来呢，我们至少要知道TypoeScript中的类是如何定义和继承的。类中还有很多知识点要讲\n\n### Demo10.ts\n\n```ts\n/**\n * Demo10.ts\n * TypeScript 类的概念和使用\n * @date 2021-1-2\n * @author Wibus\n */\n\n // TypeScript 中类的概念和 ES6 中原生类的概念大部分相同，但是也额外增加了一些新的特性\n\n// 1 类的基本使用\n// 下面是最简单的类\nclass Lady {\n    content = \"Hi，帅哥\";\n    sayHello() {\n      return this.content;\n    }\n}\n  \nconst goddess = new Lady();\nconsole.log(goddess.sayHello());\n// ts-node demo10.ts\n//result：Hi，帅哥\n\n// 2 类的继承\n// TypeScrip 的继承和ES6中的继承是一样的。关键字也是extends,比如我们这里新建一个XiaoJieJie的类，然后继承自Lady类，在XiaoJieJie类里写一个新的方法，叫做sayLove,具体代码如下。\n\nclass xiaoJieJie extends Lady{\n    sayLove(){\n        return \"I love you.\";\n    }\n}\n\nconst Wibus = new xiaoJieJie();\nconsole.log(Wibus.sayHello());\nconsole.log(Wibus.sayLove());\n// ts-node demo10.ts\n// result: Hi，帅哥 I love you.\n\n// 类写好以后，我们声明的对象是XiaoJieJie这个类，我们同时执行sayHello()和sayLove()都是可以执行到的，这说明继承起作用了\n\n// 3 类的重写\n// 讲了继承，那就必须继续讲讲重写，重写就是子类可以重新编写父类里边的代码。现在我们在XiaoJieJie这个类里重写父类的sayHello()方法\n\nclass XiaoJieJies extends Lady {\n    sayLove(){\n        return \"I love you.\";\n    }\n    sayHello() {\n        return \"Hi, honey!\";\n      }\n}\n\nconst wibus = new XiaoJieJies();\nconsole.log(wibus.sayHello());\nconsole.log(wibus.sayLove());\n// ts-node demo10.ts\n// result: Hi, honey! I love you.\n\n// 4 super 关键字的使用\n// 比如我们还是想使用Lady类中说的话，但是在后面，加上你好两个字就可以了。这时候就可以使用super关键字，它代表父类中的方法\n\nclass Xiaojiejie extends Lady {\n    sayLove() {\n        return \"I love you!\";\n      }\n      sayHello() {\n        return super.sayHello() + \".你好！\";\n      }\n}\n\nconst goddesss = new Xiaojiejie();\nconsole.log(goddesss.sayHello());\nconsole.log(goddesss.sayLove());\n// ts-node demo10.ts\n// result: Hi，帅哥.你好！I love you!\n\n// 我们至少要知道TypoeScript中的类是如何定义和继承的。类中还有很多知识点要讲\n```\n\n## 11 TypeScript 中类的访问类型\n\n上节已经简单学习了`TypeScript`中类的使用，这节我们继续学习一下类中的访问类型。其实类的访问类型就是基于三个关键词`private`、`protected`和`public`,也是三种访问类型\n\n### 11.1 简单的类\n\n我们来写一个简单的类先，我们定义一个 Person 类，然后使用这个类的对象，进行赋值，最后打印在控制台上。\n\n```ts\nclass Person {\n    name: string;\n  }\n  \nconst person = new Person();\nperson.name = \"Wibus\";\n  \nconsole.log(person.name);\n// ts-node demo11.ts\n// result: Wibus\n```\n\n写完后我们直接可以在`Terminal`(中),输入`ts-node demo11.ts`进行查看结果，结果会打印出`Wibus`\n\n### 11.2 public 访问属性\n\n这时候可以打出Wibus是因为我们如果不在类里对name的访问属性进行定义，那么它就会默认是public访问属性。所以，我们刚刚所写的类相当于这样子\n\n```ts\nclass Person2 {\n    public name: string;\n};\n```\n\n> `public`从英文字面的解释就是`公共的`或者说是`公众的`，在程序里的意思就是允许在类的`内部`和`外部`被调用.\n\n比如说，我们在类里面写一个`sayHello()` 方法，访问属性为`public`\n\n```ts\nclass Person3 {\n    public name: string;\n    public sayhello(){\n        console.log(this.name + ' say hello');\n    };\n};\n// ————————下面的是外部调用——————————\nconst person3 = new Person3;\nperson3.name = \"Wibus\";\nperson3.sayhello();\n// ts-node demo11.ts\n// result: Wibus say hello\n```\n\n这是的`this.name`就是类的内部调用。我们在下面在执行一下这个方法`person3.sayHello()`, 终端中可以看到一切正常运行了，顺利打印\n\n### 11.3 private 访问属性\n\n> `private` 访问属性的意思是，只允许在类的内部被调用，外部不允许调用\n\n现在我们把` name `属性改成`private`,这时候在类的内部使用不会提示错误，而`外部`,以及子类使用`VSCode`直接会报错。\n\n```ts\nclass Person4 {\n    private name: string;\n    private sayhello(){\n        console.log(this.name + ' say hello');\n    };\n};\n\nclass Person_Person4 extends Person4 {\n    public saySomeThing() {\n        console.log(this.name); \n    }\n}\n//VSC Error: 属性“name”为私有属性，只能在类“Person4”中访问。\n// ————————下面的是外部调用——————————\nconst person4 = new Person4;\nperson4.name = \"Wibus\";\nperson4.sayhello();\n// VSC Error: 属性“sayhello”为私有属性，只能在类“Person4”中访问。\n```\n\n### 11.4 protected 访问属性\n\n> `protected` 允许在类内及继承的子类中使用\n\n把name的访问属性换成`protected`,这时候`外部`调用`name`的代码会报错，`内部`的不会报错，和`private`一样。这时候我们再写一个`Person_Person5`类，继承于`Person4`\n\n```ts\nclass Person5 {\n    protected name: string;\n    protected sayhello(){\n        console.log(this.name + ' say hello');\n    };\n};\n\nclass Person_Person5 extends Person5 {\n    public sayBye(){\n        return \"this.name\";\n    }\n}\n\n// ————————外部调用——————————\nconst person5 = new Person5;\nperson5.name = \"Wibus\";\nperson5.sayhello();\n// VSC Error: 属性“sayhello”受保护，只能在类“Person5”及其子类中访问。\n// ————————Person_Person5 类 ——————\nconst person_person5 = new Person_Person5;\nperson_person5.sayBye(); //VSC 不报错\n```\n\n那么通过这个例子相信你一定知道什么是类的内部和类的外部，也知道了三个访问类型的区别了\n\n### Demo11.ts\n\n```ts\n/**\n * Demo11.ts\n * TypeScript 中类的访问类型\n * @date 2021-1-3\n * @author Wibus\n */\n\n// 上节已经简单学习了TypeScript中类的使用，这节我们继续学习一下类中的访问类型。其实类的访问类型就是基于三个关键词private、protected和public,也是三种访问类型\n\n// 1 简单的类\n\nclass Person {\n    name: string;\n  }\n  \nconst person = new Person();\nperson.name = \"Wibus\";\n  \nconsole.log(person.name);\n// ts-node demo11.ts\n// result: Wibus\n\n// 2 public 访问属性\n// 这时候可以打出Wibus是因为我们如果不在类里对name的访问属性进行定义，那么它就会默认是public访问属性。\n\n// 相当于\nclass Person2 {\n    public name: string;\n};\n// public从英文字面的解释就是公共的或者说是公众的，在程序里的意思就是允许在类的内部和外部被调用.\nclass Person3 {\n    public name: string;\n    public sayhello(){\n        console.log(this.name + ' say hello');\n    };\n};\n// ————————下面的是外部调用——————————\nconst person3 = new Person3;\nperson3.name = \"Wibus\";\nperson3.sayhello();\n// ts-node demo11.ts\n// result: Wibus say hello\n\n// 3 private 访问属性\n// private 访问属性的意思是，只允许在类的内部被调用，外部不允许调用\n\nclass Person4 {\n    private name: string;\n    private sayhello(){\n        console.log(this.name + ' say hello');\n    };\n};\n\nclass Person_Person4 extends Person4 {\n    public saySomeThing() {\n        console.log(this.name); \n    }\n}\n//VSC Error: 属性“name”为私有属性，只能在类“Person4”中访问。\n// ————————下面的是外部调用——————————\nconst person4 = new Person4;\nperson4.name = \"Wibus\";\nperson4.sayhello();\n// VSC Error: 属性“sayhello”为私有属性，只能在类“Person4”中访问。\n\n\n// 4 protected 访问属性\n// protected 允许在类内及继承的子类中使用\n\nclass Person5 {\n    protected name: string;\n    protected sayhello(){\n        console.log(this.name + ' say hello');\n    };\n};\n\nclass Person_Person5 extends Person5 {\n    public sayBye(){\n        return \"this.name\";\n    }\n}\n\n// ————————外部调用——————————\nconst person5 = new Person5;\nperson5.name = \"Wibus\";\nperson5.sayhello();\n// VSC Error: 属性“sayhello”受保护，只能在类“Person5”及其子类中访问。\n// ————————Person_Person5 类 ——————\nconst person_person5 = new Person_Person5;\nperson_person5.sayBye(); //VSC 不报错\n```\n\n## 12 TypeScript 类的构造函数\n\n构造函数就是在类被初始化的时候，自动执行的一个方法。我们通过这个构造方法经常作很多需要提前完成的工作，比如显示页面前我们要从后台得到数据\n\n### 12.1 类的构造函数\n\n简单来说，构造函数的关键字就是`constructor`\n\n新建一个` Person` 类，类的里边定义一个`name`，但是`name`我们并不给他值,然后我们希望在`new`出对象的时候，直接通过传递参数的形式，给`name`赋值，并打印出来。这时候我们就需要用到`构造函数`了\n\n```ts\nclass Person{\n    public name: string;\n    constructor(name:string){\n        this.name = name;\n    };\n};\n\nconst person = new Person('Wibus');\nconsole.log(person.name);\n// ts-node demo12.ts\n// result: Wibus\n```\n\n这是最常规和好理解的写法，那么既然都这么说了，就是有更简单的写法啦\n\n#### 12.1.1 简单的写法\n\n```ts\nclass Person2 {\n    constructor(public name:string){} // 这个地方的name需要写上访问属性\n};\n\nconst person2 = new Person2('Wibus2');\nconsole.log(person2.name);\n```\n\n这种写法就相当于你定义了一个`name`,然后在构造函数里进行了赋值，这是一种简化的语法\n\n### 12.2 类继承中的构造器写法\n\n普通类的构造器我们已经会了，在子类中使用构造函数需要用`super()`调用父类的构造函数，如果你看不懂我在说啥的话，看下面的代码\n\n```ts\nclass Teacher extends Person2 {\n    constructor(public age: number){\n        super('Wibus');\n    };\n};\n\nconst teacher = new Teacher(18);\nconsole.log(teacher.age);\nconsole.log(teacher.name);\n```\n\n如果你不写`super('Wibus');`的话，VSC将会报错：派生类的构造函数必须包含 \"super\" 调用。\n\n当然你可以`super('');` 直接过去😂\n\n> 父类没有构造函数，子类也要使用`super()`进行调用，否则就会报错。\n\n```ts\nclass Person3 {};\n\nclass Teacher2 extends Person3 {\n    constructor(public age: number){\n        super();\n    };\n};\n\nconst teacher2 = new Teacher2(18);\nconsole.log(teacher2.age);\n```\n\n这一节主要讲的就是类中的构造函数（也有叫构造器的），构造函数在工作中用的很多，所以你要学会并作充分的练习～\n\n### Demo12.ts\n\n```ts\n/**\n * Demo12.ts\n * TypeScript 类的构造函数\n * @date 2021-1-3\n * @author Wibus\n * 构造函数就是在类被初始化的时候，自动执行的一个方法。我们通过这个构造方法经常作很多需要提前完成的工作，比如显示页面前我们要从后台得到数据\n */\n\n// 1 类的构造函数\n//构造函数的关键字是constructor\n\nclass Person{\n    public name: string;\n    constructor(name:string){\n        this.name = name;\n    };\n};\n\nconst person = new Person('Wibus');\nconsole.log(person.name);\n// ts-node demo12.ts\n// result: Wibus\n// 这是最常规和好理解的写法\n\n// 1.1 简单的写法\n\nclass Person2 {\n    constructor(public name:string){} // 这个地方的name需要写上访问属性\n};\n\nconst person2 = new Person2('Wibus2');\nconsole.log(person2.name);\n// 这种写法就相当于你定义了一个name,然后在构造函数里进行了赋值，这是一种简化的语法\n\n// 2 类继承中的构造器写法\n// 普通类的构造器我们已经会了，在子类中使用构造函数需要用super()调用父类的构造函数\n\nclass Teacher extends Person2 {\n    constructor(public age: number){\n        super('Wibus');\n    };\n};\n\nconst teacher = new Teacher(18);\nconsole.log(teacher.age);\nconsole.log(teacher.name);\n\n// 父类没有构造函数，子类也要使用super()进行调用，否则就会报错。\n\nclass Person3 {};\n\nclass Teacher2 extends Person3 {\n    constructor(public age: number){\n        super();\n    };\n};\n\nconst teacher2 = new Teacher2(18);\nconsole.log(teacher2.age);\n\n// 主要讲的就是类中的构造函数（也有叫构造器的），构造函数在工作中用的很多，所以你要学会并作充分的练习。\n```"},{"title":"一起入手TypeScript（三）","slug":"typescript-3","created":"2021-01-02T05:13:43.268Z","modified":"2021-01-02T09:48:57.625Z","content":"\n\n## 7 TypeScript 元组的使用和类型约束\n\n元组是TS特有的一个概念，JavaScript并没有这个概念\n\n### 7.1 元组的基本使用\n\n我们先来看一个例子\n\n```ts\nconst xiaojiejie = [\"Qwq\", \"NoJob\", 28];\n```\n\n这时候把鼠标放到xiaojiejie变量上面，可以看出`推断`出来的类型。我们就用`类型注解`的形式给他作一个注解\n\n```ts\nconst zhujie_xiaojiejie : (number | string)[] = [\"Qwq\", \"NoJob\", 28];\n```\n\n这个时候你已经添加了`类型注解`，但是在下面的代码当中会有一个`小细节问题`\n\n```ts\nconst Badxiaojiejie: (number | string)[] = [\"Qwq\", 28, \"NoJob\"];\n```\n\n我们只是把数组的位置调换了一下，但是`TS`并不能发现这个问题，所以我们需要一个更强大的类型，来解决，所以，这就是`元组`\n\n元组和数组比较类似，但是类型注解的时候有点不一样\n\n```ts\nconst Shuzu_xiaojiejie: [string, string, number] = [\"Qwq\", \"NoJob\", 28];\n```\n\n这个样子我们就把每个类型的位置都固定住了，这就叫做元组\n\n#### 7.2 元组的使用\n\n我们假设有这样子的一组数据\n\n```ts\n\"dajiao\", \"teacher\", 28;\n\"liuying\", \"teacher\", 18;\n\"cuihua\", \"teacher\", 25;\n```\n\n如果是这个样子的话，我们可以看到前两个都是字符串，最后一个是常数。\n\n```ts\nconst xiaojiejies: [string, string, number][] = [\n  [\"dajiao\", \"teacher\", 28],\n  [\"liuying\", \"teacher\", 18],\n  [\"cuihua\", \"teacher\", 25],\n];\n```\n\n你要搞清楚元组和数组的区别，在理解后能在项目中适当的时候使用不同的类型。\n\n### Demo7.ts\n\n```ts\n/**\n * Demo7.ts\n * TypeScript 元组的使用和类型约束\n * @date 2021-1-2\n * @author Wibus\n */\n\n//元组是TS特有的一个概念，JavaScript并没有这个概念\n\n// 1 元组的基本使用\nconst xiaojiejie = [\"Qwq\", \"NoJob\", 28];\n// 把上面的进行类型注解\nconst zhujie_xiaojiejie : (number | string)[] = [\"Qwq\", \"NoJob\", 28];\n// 这个时候你已经添加了类型注解，但是在下面的代码当中会有一个小细节问题\nconst Badxiaojiejie: (number | string)[] = [\"Qwq\", 28, \"NoJob\"];\n//我们只是把数组的位置调换了一下，但是TS并不能发现这个问题，所以我们需要一个更强大的类型，来解决，所以，这就是元组\nconst Shuzu_xiaojiejie: [string, string, number] = [\"Qwq\", \"NoJob\", 28];\n// 这个时候我们就已经把每一个类型都固定住了\n\n// 2 元组的使用\n\n// 得到的数据源是这样子的：\n// \"dajiao\", \"teacher\", 28;\n// \"liuying\", \"teacher\", 18;\n// \"cuihua\", \"teacher\", 25;\n\nconst xiaojiejies: [string, string, number][] = [\n  [\"dajiao\", \"teacher\", 28],\n  [\"liuying\", \"teacher\", 18],\n  [\"cuihua\", \"teacher\", 25],\n];\n\n// 你要搞清楚元组和数组的区别，在理解后能在项目中适当的时候使用不同的类型。\n```\n\n## 8 TypeScript 的 interface接口\n\nTypeScript的接口。就是用来规范类型的\n\n### 8.1 Interface 接口初步了解\n\n我们要作一个简历的自动筛选程序，很简单。年龄小于 25 岁，胸围大于 90 公分的，可以进入面试环节。我们最开始的写法是这样的\n\n```ts\nconst screenresume = (name: string, age: number, bust: number) => {\n    age < 24 && bust >= 90 && console.log(name + \"Pass\");\n    age > 24 || (bust < 90 && console.log(name + \"Can't Pass\"));\n};\n\nscreenresume(\"Wibus\", 14, 90);\n```\n\n好像还不错，我们再加上个查看简历的功能，于是你的代码是这样\n\n```ts\nconst getResume = (name: string, age: number, bust: number) => {\n    console.log(name+ \"age: \" + age);\n    console.log(name+ \"Bust: \" + bust);\n}\ngetResume(\"Wibus\", 14, 90);\n```\n\n但是这个时候会发现，有很多东西重复了，程序开发中一直强调“代码重用”，两个方法用的类型注解一样，需要作个统一的约束。大上节课我们学了一个`类型别名`的知识可以解决代码重复的问题，这节课我们就学习一个更常用的语法`接口`（Interface）.\n\n我们可以把这两个重复进行类型注解，定义成统一的接口。代码如下\n\n```ts\ninterface Girl {\n  name: string;\n  age: number;\n  bust: number;\n}\n```\n\n有了这个接口后我们程序也要做一些修改\n\n```ts\nconst screenresume2 = (girl: Girl) => {\n    girl.age < 24 && girl.bust >= 90 && console.log(girl.name + \"Pass\");\n    girl.age > 24 || (girl.bust < 90 && console.log(girl.name + \"Can't Pass\"));\n};\n\nconst getResume2 = (girl: Girl) => {\n    console.log(girl.name+ \"age: \" + girl.age);\n    console.log(girl.name+ \"Bust: \" + girl.bust);\n};\n\nconst girl = {\n    name: \"Wibus\",\n    age: 14,\n    bust: 94,\n};\n\nscreenresume2(girl);\ngetResume2(girl);\n```\n这样就更像是面向对象编程了,以后再用到同样的接口也不怕了，直接使用girl就可以了。\n\n### 8.2 接口和类型别名的区别\n\n现在我们学了`接口`，也学过了`类型别名`，这两个语法和用处好像一样, 确实用起来基本一样，但是也有少许的不同。\n\n> 类型别名可以直接给类型，比如string，而接口必须代表对象。\n\n比如我们的类型别名可以写出下面的代码：\n```ts\ntype Girl1 = stirng;\n```\n但是接口就不能这样写，它必须代表的是一个对象，也就是说，你初始化`girl`的时候，必须写出下面的形式.\n```ts\nconst girl = {\n  name: \"大脚\",\n  age: 18,\n  bust: 94,\n};\n```\n\n### 8.3 接口非必选值定义\n\n我们要求尽量能看到小姐姐的腰围，但是不作强制要求，就是`可选值`。那接口如何定义？`typeScript`已经为我们准备好了相应的办法，就是在 *:* 号前加一个 *?*\n\n比如把Girl的接口写成这样。\n\n```ts\ninterface Girl2 {\n  name: string;\n  age: number;\n  bust: number;\n  waistline?: number; // 非必选值\n}\n```\n\n再修改一下getResume方法，写成这样。\n\n```ts\nconst getResume3 = (girl: Girl2) => {\n  console.log(girl.name + \"年龄是：\" + girl.age);\n  console.log(girl.name + \"胸围是：\" + girl.bust);\n  girl.waistline && console.log(girl.name + \"腰围是：\" + girl.waistline);\n};\n```\n\n这时候在定义`girl对象`的时候，就可以写`saistline`（腰围），也可以不写了。\n\n### Demo8.ts\n\n```ts\n/**\n * Demo8.ts\n * TypeScript 的 interface 接口\n * @date 2021-1-2\n * @author Wibus\n * interface东西比较多，分两次讲述\n */\n\n// 1 interface 接口初步了解\n\n// 1.1 简历工具\nconst screenresume = (name: string, age: number, bust: number) => {\n    age < 24 && bust >= 90 && console.log(name + \"Pass\");\n    age > 24 || (bust < 90 && console.log(name + \"Can't Pass\"));\n};\n\nscreenresume(\"Wibus\", 14, 90);\n// ts-node demo8.ts\n// 进入面试\n\n\nconst getResume = (name: string, age: number, bust: number) => {\n    console.log(name+ \"age: \" + age);\n    console.log(name+ \"Bust: \" + bust);\n}\n\n// 但是似乎name: string, age: number, bust: number一直在出现\n// 为了避免啊代码重用，我们可以使用接口\n\ninterface Girl {\n    name: string;\n    age: number;\n    bust: number;\n}\n// 于是我们就需要修改一点程序\nconst screenresume2 = (girl: Girl) => {\n    girl.age < 24 && girl.bust >= 90 && console.log(girl.name + \"Pass\");\n    girl.age > 24 || (girl.bust < 90 && console.log(girl.name + \"Can't Pass\"));\n};\n\nconst getResume2 = (girl: Girl) => {\n    console.log(girl.name+ \"age: \" + girl.age);\n    console.log(girl.name+ \"Bust: \" + girl.bust);\n};\n\nconst girl = {\n    name: \"Wibus\",\n    age: 14,\n    bust: 94,\n};\n\nscreenresume2(girl);\ngetResume2(girl);\n\n// 2 接口和类型别名的区别\n\ntype Girl1 = string;\n\nconst girl1 = {\n    name: \"Wibus\",\n    age: 14,\n    bust: 94 \n};\n\n// 3 接口非必选值定义\n\ninterface Girl2 {\n  name: string;\n  age: number;\n  bust: number;\n  waistline?: number; // 非必选值\n}\n\nconst getResume3 = (girl: Girl2) => {\n  console.log(girl.name + \"年龄是：\" + girl.age);\n  console.log(girl.name + \"胸围是：\" + girl.bust);\n  girl.waistline && console.log(girl.name + \"腰围是：\" + girl.waistline);\n};\n\n//这时候在定义girl对象的时候，就可以写saistline（腰围），也可以不写了。\n```\n\n## 9 TypeScript 的 interface 接口 2\n\n我们接着继续讲接口，接口部分的内容还是比较多的\n\n### 9.1 允许加入任意值\n\n简历一般是有自由发挥的空间的，所以这时候需要一些任意值，就是自己愿意写什么就写什么。这时候interface接口也是支持的。\n\n```ts\ninterface Girl1 {\n    name: string;\n    age: number;\n    bust: number;\n    waistline?: number;\n    [propname: string]: any; //属性的名字是字符串类型，属性的值可以是任何类型。\n  }\n```\n\n`propname` 你可以随意改成其他的名字～\n\n这时候我们在对象里给一个性别\n\n```ts\nconst girl = {\n    name: \"大脚\",\n    age: 18,\n    bust: 94,\n    waistline: 21,\n    sex: \"女\",\n  };\n```\n\n再修改一下代码，就没有错误了。\n\n```ts\nconst getResume = (girl: Girl1) => {\n    console.log(girl.name + \"年龄是：\" + girl.age);\n    console.log(girl.name + \"胸围是：\" + girl.bust);\n    girl.waistline && console.log(girl.name + \"腰围是：\" + girl.waistline);\n    girl.sex && console.log(girl.name + \"性别是：\" + girl.sex);\n  };\n```\n\n这时候我们的程序是不报错的，但是如果我们去掉刚才的设置，就会报错。\n\n```ts\n[propname:string]:any;  //去掉\n```\n\n### 9.2 接口里的方法\n\n接口里不仅可以存属性，还可以存方法，比如这时候有个`say()`方法，返回值是`string`类型。这时候你就不要再想成简历了，你需要更面向对象化的编程，想象成一个人。\n\n```ts\ninterface Girl2 {\n    name: string;\n    age: number;\n    bust: number;\n    waistline?: number;\n    [propname: string]: any;\n    say(): string;\n}\n```\n\n加上这个`say()`方法后，程序马上就会报错，因为我们对象里没有` say `方法。那我们就要给对象一个` say `方法\n\n```ts\nconst girl2 = {\n  name: \"Wibus\",\n  age: 14,\n  bust: 94,\n  waistline: 21,\n  sex: \"女\",\n  say() {\n    return \"欢迎光临 ，红浪漫洗浴！！\";\n  },\n};\n```\n\n### 9.3 接口和类的约束\n\n` JavaScript `从ES6里是有类这个概念的，类可以和接口很好的结合\n\n```ts\nclass XiaoJieJie implements Girl {}\n```\n\n这时候类会直接报错，所以我们需要把这个类写的完全点。\n\n```ts\nclass xiaojiejie implements Girl2 {\n    name: \"大脚\";\n    age: 18;\n    bust: 94;\n    waistline: 21;\n    sex: \"女\";\n    say() {\n      return \"欢迎光临 ，红浪漫洗浴！！\";\n    };\n};\n```\n\n### 9.4 接口的继承\n\n接口也可以用于继承的，比如你新写一个`Teacher`接口，继承于`Person`接口。\n\n```ts\ninterface Teacher extends Girl2{\n    teach(): string;\n}\n```\n\n比如这时候，只看` Teacher `级别的简历，那我们需要修改`getResume()`方法。\n\n```ts\nconst getResume2 = (girl2: Teacher) => {\n    console.log(girl2.name + \"年龄是：\" + girl2.age);\n    console.log(girl2.name + \"胸围是：\" + girl2.bust);\n    girl2.waistline && console.log(girl2.name + \"腰围是：\" + girl2.waistline);\n    girl2.sex && console.log(girl2.name + \"性别是：\" + girl2.sex);\n};\ngetResume2(girl2);\n```\n\n修改后，你就会发现下面我们调用`getResume2()`方法的地方报错了,因为这时候传的值必须有`Teach`方法，修改`girl`对象，增加`teach（）`方法，这时候就不会报错了。\n\n```ts\nconst girl2 = {\n  name: \"Wibus\",\n  age: 14,\n  bust: 94,\n  waistline: 21,\n  sex: \"女\",\n  say() {\n    return \"欢迎光临 ，红浪漫洗浴！！\";\n  },\n    teach() {\n    return \"我是一个老师\";\n  },\n};\n```\n\n关于接口的知识就讲到这里吧，这基本包含了接口 80%的知识\n\n## Demo9.ts\n\n```ts\n/**\n * Demo9.ts\n * TypeScript 的 interface 接口 2\n * @date 2021-1-2\n * @author Wibus\n */\n\n // 1 允许加入任意值\n//  简历一般是有自由发挥的空间的，所以这时候需要一些任意值，就是自己愿意写什么就写什么。这时候interface接口也是支持的。\ninterface Girl1 {\n    name: string;\n    age: number;\n    bust: number;\n    waistline?: number;\n    [name: string]: any; //属性的名字是字符串类型，属性的值可以是任何类型。\n  }\n// 这时候我们在对象里给一个性别\nconst girl = {\n    name: \"大脚\",\n    age: 18,\n    bust: 94,\n    waistline: 21,\n    sex: \"女\",\n  };\n//   再修改一下代码，就没有错误了。\nconst getResume = (girl: Girl1) => {\n    console.log(girl.name + \"年龄是：\" + girl.age);\n    console.log(girl.name + \"胸围是：\" + girl.bust);\n    girl.waistline && console.log(girl.name + \"腰围是：\" + girl.waistline);\n    girl.sex && console.log(girl.name + \"性别是：\" + girl.sex);\n  };\n// 这时候我们的程序是不报错的，但是如果我们去掉刚才的设置，就会报错。\n\n// 2 接口里的方法\n// 接口里不仅可以存属性，还可以存方法，比如这时候有个say()方法，返回值是string类型。这时候你就不要再想成简历了，你需要更面向对象化的编程，想象成一个人。\n\ninterface Girl2 {\n    name: string;\n    age: number;\n    bust: number;\n    waistline?: number;\n    [propname: string]: any;\n    say(): string;\n  }\n// 加上这个say()方法后，程序马上就会报错，因为我们对象里没有 say 方法。那我们就要给对象一个 say 方法\n\nconst girl2 = {\n  name: \"Wibus\",\n  age: 14,\n  bust: 94,\n  waistline: 21,\n  sex: \"女\",\n  say() {\n    return \"欢迎光临 ，红浪漫洗浴！！\";\n  },\n    teach() {\n    return \"我是一个老师\";\n  },\n};\n\n// 3 接口和类的约束\n// 类和接口能有很好的结合\n\nclass xiaojiejie implements Girl2 {\n    name: \"大脚\";\n    age: 18;\n    bust: 94;\n    waistline: 21;\n    sex: \"女\";\n    say() {\n      return \"欢迎光临 ，红浪漫洗浴！！\";\n    };\n};\n\n// 4 接口的继承\n// 接口也可以用于继承的，比如你新写一个Teacher接口，继承于Person接口。\n\ninterface Teacher extends Girl2{\n    teach(): string;\n}\n\n// 比如这时候，只看 Teacher 级别的简历，那我们需要修改getResume()方法。\nconst getResume2 = (girl2: Teacher) => {\n    console.log(girl2.name + \"年龄是：\" + girl2.age);\n    console.log(girl2.name + \"胸围是：\" + girl2.bust);\n    girl2.waistline && console.log(girl2.name + \"腰围是：\" + girl2.waistline);\n    girl2.sex && console.log(girl2.name + \"性别是：\" + girl2.sex);\n  };\n  \ngetResume2(girl2);\n```"},{"title":"一起入手Typescript（二）","slug":"typescript-2","created":"2021-01-02T03:00:33.992Z","modified":"2021-01-02T04:06:19.101Z","content":"\n\n## 4 Typescript的类型注解和类型推断\n\nTypeScript 中的两个基本概念：`类型注解`和`类型推断`，这两个概念在我们编写 TypeScript 代码时会一直使用(重点)，但很多教程都没有讲解，不过在官方文档中有比较好的解释。你现在可能还不能完全理解我说的这两个概念，但是你看完文章后就会有很直观的了解啦\n\n### 4.1 type annotation 类型注解\n\n我们直接点，直接看代码\n\n```ts\nlet countDemo4: number;\ncountDemo4 = 123;\n```\n\n这段代码就是类型注解，意思是显示的告诉代码，我们的count变量就是一个数字类型，这就叫做类型注解\n\n### 4.2 type inferrence 类型推断\n\n当你明白了`类型注解`的概念之后，再学`类型推断`就更简单了，先来看一段代码。还是在Demo4.ts文件中写入下面的代码。\n\n```ts\nlet countInterfence = 123; //let countInterfence: number\n```\n\n这时候我并没有显示的告诉你变量countInference是一个`数字类型`，但是如果你把鼠标放到变量上时，你会发现 TypeScript `自动`把变量注释为了number（数字）类型，也就是说它是有某种推断能力的，通过你的代码 `TS` 会自动的去尝试`分析变量的类型`\n\n#### 4.2.1 工作使用问题（潜规则）\n\n- 如果 `TS` 能够自动分析变量类型， 我们就什么也不需要做了\n- 如果 `TS` 无法分析变量类型的话， 我们就需要使用类型注解\n\n#### 4.2.2 不需要注解例子\n\n我们来看两个例子，先是一个不需要注解的\n\n```ts\nconst one = 123;\nconst two = \"abc\";\nconst three = one + two;\n```\n\n#### 4.2.3 需要写的例子\n\n```ts\nfunction getTotal(one, two) {\n    return one + two;\n  }\nconst total = getTotal(1, 2); //正常情况\nconst Warningtotal = getTotal(1, \"字符串\"); //非正常情况\n```\n\n这种形式，就需要用到`类型注释`了，因为这里的one和two会显示为any类型。这时候如果你传字符串，你的逻辑就是*错误*的，所以你必须加一个`类型注解`\n\n```ts\nfunction GoodgetTotal(one: number, two: number) {\n    return one + two;\n  }\nconst Goodtotal = getTotal(1, 2); \n```\n\n为什么total这个变量不需要加类型注解，因为当one和two两个变量加上注解后，TypeScript 就可以自动通过类型推断，分析出变量的类型。\n\n#### 4.2.4 推断对象中属性的类型\n\n当然 TypeScript 也可以推断出对象中属性的类型，比如现在写一个小姐姐的对象，然后里边有两个属性。\n\n```ts\n\nconst XiaoJieJie = {\n    name: \"刘英\",\n    age: 18,\n  };\n\n/* \nconst XiaoJieJie: {\n    name: string;\n    age: number;\n}\n */\n\n```\n\n写完后你把鼠标放在XiaoJieJie对象上面，就会提示出他里边的属性，这表明 TypeScript 也分析出了对象的属性的类型。\n\n在写 TypeScript 代码的一个重要宗旨就是每个变量，每个对象的属性类型都应该是固定的，如果你推断就让它推断，推断不出来的时候你要进行注释。\n\n### Demo4.ts\n\n```ts\n/**\n* Demo4.ts\n * 类型注解 & 类型推断\n * @date 2021-1-1\n * @author Wibus\n * TypeScript 中的两个基本概念：类型注解和类型推断，这两个概念在我们编写 TypeScript 代码时会一直使用(重点)\n */\n\n // 1 type annotation 类型注解\nlet countDemo4: number;\ncountDemo4 = 123;\n// 这段代码就是类型注解，意思是显示的告诉代码，我们的count变量就是一个数字类型，这就叫做类型注解\n\n // 2 type inferrence 类型推断\n let countInterfence = 123; //let countInterfence: number\n /**\n  * 我并没有显示的告诉你变量countInference是一个数字类型，但是如果你把鼠标放到变量上时，你会发现 TypeScript 自动把变量注释为了number（数字）类型\n  * 也就是说它是有某种推断能力的，通过你的代码 TS 会自动的去尝试分析变量的类型。\n  * 这个就彷佛是人的情商比较高，还没等女生表白，你就已经看出她的心思🤣\n  */\n\n  /**\n   * 如果 TS 能够自动分析变量类型， 我们就什么也不需要做了\n   * 如果 TS 无法分析变量类型的话， 我们就需要使用类型注解\n   */\n\n// 3 不需要写注解的例子 🌰\nconst one = 123;\nconst two = \"abc\";\nconst three = one + two;\n\n// 4 需要写的例子 🌰\nfunction getTotal(one, two) {\n    return one + two;\n  }\nconst total = getTotal(1, 2); //正常情况\nconst Warningtotal = getTotal(1, \"字符串\"); //非正常情况\n//   这种形式，就需要用到类型注释了，因为这里的one和two会显示为any类型。这时候如果你传字符串，你的逻辑就是错误的，所以你必须加一个类型注解\nfunction GoodgetTotal(one: number, two: number) {\n    return one + two;\n  }\nconst Goodtotal = getTotal(1, 2); \n// 为什么total这个变量不需要加类型注解，因为当one和two两个变量加上注解后，TypeScript 就可以自动通过类型推断，分析出变量的类型。\n\n// 5 推断对象中属性的类型\n/* \nconst XiaoJieJie: {\n    name: string;\n    age: number;\n}\n */\nconst XiaoJieJie = {\n    name: \"刘英\",\n    age: 18,\n  };\n\n\n// 写 TypeScript 代码的一个重要宗旨就是每个变量，每个对象的属性类型都应该是固定的，如果你推断就让它推断，推断不出来的时候你要进行注释。\n```\n\n## 5 TypeScript 函数参数和返回类型定义\n\n### 5.1 简单类型定义\n\n上次我们写了一个getTotal的函数，并且对传入的参数作了定义，我们再复习一遍。\n\n新建一个文件demo5.ts,然后写入代码\n\n```ts\nfunction LastgetTotal(one: number, two: number) {\n    return one + two;\n}\nconst LastTotal = LastgetTotal(1, 2);\n```\n\n代码其实有一个小坑，就是我们并没有定义getTotal的返回值类型，虽然TypeScript可以自己推断出返回值是number类型。 但是如果这时候我们的代码写错了，比如写成了下面这个样子。\n\n```ts\nfunction BadgetTotal(one: number, two: number) {\n    return one + two + \"\";\n  }\n  \nconst Badtotal = BadgetTotal(1, 2); \n```\n\n这时候total的值就不是number类型了，但是不会报错。有的小伙伴这时候可能会说，可以直接给total一个类型注解，比如写成这个样子。\n\n```ts\nconst total: number = getTotal(1, 2);\n```\n\n这样写虽然可以让编辑器报错，但是这还不是很高明的算法，因为你没有找到错误的根本，这时错误的根本是getTotal()函数的错误，所以合适的做法是给函数的返回值加上类型注解，代码如下：\n\n```ts\nfunction BettergetTotal(one: number, two: number): number {\n    return one + two;\n}\nconst BetterTotal = BettergetTotal(1, 2);\n//这段代码就比较严谨了\n```\n\n### 5.2 函数无返回值时定义方法\n有时候函数是没有返回值的，比如现在定义一个sayHello的函数，这个函数只是简单的terminal打印，并没有返回值。\n```ts\nfunction sayHello() {\n  console.log(\"hello world\");\n}\n```\n这就是没有返回值的函数，我们就可以给他一个类型注解void，代表没有任何返回值。\n```ts\nfunction sayHello(): void {\n  console.log(\"hello world\");\n}\n```\n如果这样定义后，你再加入任何返回值，程序都会报错。\n\n### 5.3 never 返回值类型\n如果一个函数是永远也执行不完的，就可以定义返回值为never，那什么样的函数是永远也执行不完的那?我们先来写一个这样的函数(比如执行执行的时候，抛出了异常，这时候就无法执行完了)。\n```ts\nfunction errorFuntion(): never {\n  throw new Error();\n  console.log(\"Hello World\");\n}\n```\n还有一种是一直循环，也是我们常说的死循环，这样也运行不完，比如下面的代码：\n```ts\nfunction forNever(): never {\n  while (true) {}\n  console.log(\"Hello \");\n}\n```\n### 5.4 函数参数为对象(解构)时\n这个坑有很多小伙伴掉下去过，就是当一个函数的参数是对象时，我们如何定义参数对象的属性类型。我先写个一般javaScript的写法。\n```ts\nfunction add({ one, two }) {\n  return one + two;\n}\n\nconst total = add({ one: 1, two: 2 });\n```\n在浏览器中你会看到直接报错了，意思是total有可能会是任何类型，那我们要如何给这样的参数加类型注解那？最初你可能会这样写。\n```ts\nfunction add({ one: number, two: number }) {\n  return one + two;\n}\n\nconst total = add({ one: 1, two: 2 });\n```\n你在编辑器中会看到这种写法是完全错误的。那正确的写法应该是这样的。\n```ts\nfunction add({ one, two }: { one: number, two: number }): number {\n  return one + two;\n}\n\nconst three = add({ one: 1, two: 2 });\n```\n如果参数是对象，并且里边只有一个属性时，我们更容易写错。 错误代码如下：\n```ts\nfunction getNumber({ one }: number) {\n  return one;\n}\n\nconst one = getNumber({ one: 1 });\n```\n看着好像没什么问题，但实际这是有问题的，正确的代码应该时这样的。\n```ts\nfunction getNumber({ one }: { one: number }): number {\n  return one;\n}\n\nconst one = getNumber({ one: 1 });\n```\n这样写才是正确的写法\n\n## Demo5.ts\n```ts\n/**\n * Demo5.ts\n * TypeScript 函数参数和返回类型定义\n * @date 2021-1-1\n * @author Wibus\n */\n\n\n// 1 复习下demo4的getTotal\nfunction LastgetTotal(one: number, two: number) {\n    return one + two;\n}\nconst LastTotal = LastgetTotal(1, 2);\n//  代码其实有一个小坑，就是我们并没有定义getTotal的返回值类型，虽然TypeScript可以自己推断出返回值是number类型。 但是如果这时候我们的代码写错了，比如写程了下面这个样子。\nfunction BadgetTotal(one: number, two: number) {\n    return one + two + \"\";\n  }\n  \nconst Badtotal = BadgetTotal(1, 2); //这时候total的值就不是number类型了，但是不会报错。\n// 1.1 某些人的解决办法\nconst SomePersontotal: number = BadgetTotal(1, 2); //这样写虽然可以让编辑器报错(不能将类型“string”分配给类型“number”。)，但是这还不是很高明的算法，因为你没有找到错误的根本\n\n// 1.2 合适的做法是给函数的返回值加上类型注解\n\nfunction BettergetTotal(one: number, two: number): number {\n    return one + two;\n}\nconst BetterTotal = BettergetTotal(1, 2);\n//这段代码就比较严谨了\n\n// 2 never 返回值类型\n// 如果一个函数是永远也执行不完的，就可以定义返回值为never\nfunction errorFuntion(): never {\n    throw new Error();\n    console.log(\"Hello World\");\n}\n// 👆执行执行的时候，抛出了异常，这时候就无法执行完了\n\n//void 无返回值类型\nfunction avoid(): void {\n    const a = 123\n    //这个时候这个函数里面是不允许return一个值的\n    return a;\n}\n\nfunction forNever(): never {\n  while (true) {}\n  console.log(\"Hello\");\n}\n// ⬆️死循环，这样也运行不完\n```\n\n## 6 TypeScript 中数组类型的定义\nTypeScript 中的数组类型，一般的数组类型定义我们已经接触过了，只是没有单独拿出来讲，所以先来复习一下。\n \n### 6.1 一般数组类型的定义\n\n我们我们先定义一个最最最简单的数组\n\n```ts\nconst numberArr = [1,2,3]'\n```\n\n这时候你把鼠标放在`numberArr`上面可以看出，这个数组的类型就是 *number* 类型。这是 TypeScript 通过`类型推断`自己推断出来的。 如果你要显示的`注解`，也非常简单，可以写成下面的形式。\n```ts\nconst numberArr: number[] = [1, 2, 3];\n```\n同样道理，如果你的数组各项是字符串，你就可以写成这样\n```ts\nconst stringArr: string[] = [\"a\", \"b\", \"c\"];\n```\n也就是说你可以定义任意类型的数组，比如是`undefined`\n```ts\nconst undefinedArr: undefined[] = [undefined, undefined];\n```\n\n这时候问题来了，如果数组中有多种类型，比如既有数字类型，又有字符串的时候。那我们要如何定义那。 很简单，只要加个()，然后在里边加上|就可以了，具体看代码。\n\n```ts\nconst arr: (number | string)[] = [1, \"string\", 2];\n```\n数组简单类型的定义就是这样了，并不难。\n\n### 6.2 数组中对象类型的定义\n\n在实际项目当中肯定会有对象出现，那这个时候定义的话就麻烦一点点了\n\n```ts\nconst xiaoJieJiesDemo6: {name: string, age: number}[] = [\n    {name: \"Ming\", age: 15},\n    {name: \"Wibus\", age: 14},\n];\n```\n\n这样子的形式看起来比较复杂，当然这段程序是可以的，但是不好读嘛\n\n#### 6.2.1 Type Alias 类型别名\n\n`TS` 为我们弄了一个`类型别名`，使用type+名字，具体看代码\n\n```ts\ntype lady = {name: string, age: number};\n\nconst GoodxiaoJieJiesDemo6: lady[] = [\n    {name: \"Ming\", age: 15},\n    {name: \"Wibus\", age: 14},\n];\n```\n这样子就好读多了\n\n#### 6.2.2 Class定义\n\n当然，使用class来定义也是可以的，例如这样子\n\n```ts\nclass ladys{\n    name: string;\n    age: number;\n};\nconst GoodxiaoJieJiesDemo6_2: ladys[] = [\n    {name: \"Ming\", age: 15},\n    {name: \"Wibus\", age: 14},   \n];\n```\n\n我们可以看到，是可以的~\n\n### Demo6.ts\n\n```ts\n/**\n * Demo6.ts\n * TypeScript 中数组类型的定义\n * @date 2021-1-2\n * @author wibus\n */\n\n// 1 一般数组类型的定义\nconst numberArr = [1,2,3];\n// 这是最简单的数组类型（number) 当你鼠标放上变量名时，就可以看得出来是number类型（类型推断）\nconst numberArr2: number[] = [1,2,3];\n// 类型注解\nconst stringArr: string[] = [\"a\",\"b\",\"c\"];\n// 所以说你可以定义任何类型的数组\nconst undefinedArr: undefined[] = [undefined, undefined];\n// 1.1 多种数据类型\nconst arr: (number|string)[] = [1,2,\"abc\"];\n// 数组简单类型定义就这样了，其实不难\n\n// 2 数组中对象类型的定义\n// 在实际项目当中肯定会有对象出现，那这个时候定义的话就麻烦一点点了\n\nconst xiaoJieJiesDemo6: {name: string, age: number}[] = [\n    {name: \"Ming\", age: 15},\n    {name: \"Wibus\", age: 14},\n];\n//这样子的形式看起来比较复杂，当然这段程序是可以的，但是不好读嘛\n\n// 2.1 Type Alias 类型别名\n\ntype lady = {name: string, age: number};\nconst GoodxiaoJieJiesDemo6: lady[] = [\n    {name: \"Ming\", age: 15},\n    {name: \"Wibus\", age: 14},\n];\n//这样子就好读多了\n\n// 2.2 使用class\n// 当然，使用class来定义也是可以的，例如这样子\nclass ladys{\n    name: string;\n    age: number;\n};\nconst GoodxiaoJieJiesDemo6_2: ladys[] = [\n    {name: \"Ming\", age: 15},\n    {name: \"Wibus\", age: 14},   \n]\n// 我们可以看到，是可以的~\n```"},{"title":"一起入手TypeScript（一）","slug":"typescript-1","created":"2021-01-01T01:16:41.899Z","modified":"2021-01-02T03:00:47.792Z","content":"\n\n> 从一起小白到一起精通～\n\n我们将会一起从小白到精通的吧！\n\n## 1 Typescript环境搭建\n\n如果你想使用 TypeScript 来编写代码，你需要先安装一下它的开发环境，这并不复杂。\n\n1.安装 `Node` 的运行环境\n\n你可以到`Node.js`官网去下载 Node 进行安装(https://node.js.org)，建议你下载LTS版本,也就是长期支持版本。安装的过程我就不演示了，这个过程就和安装 QQ 一样，没有任何难度。\n\n如果你已经安装了，可以打开命令行工具，然后使用node -v命令查看安装的版本，但是一般还有一个命令需要检测一下，就是npm -v,如果两个命令都可以输出版本号，说明你的 Node 安装已经没有任何问题了。\n\n2.`全局安装` typeScript\n\n你要使用 TypeScript 先要在你的系统中全局安装一下TypeScript，这里你可以直接在 VSCode 中进行安装，安装命令可以使用` npm` 也可以使用 `yarn`\n\n```sh\nnpm install typescript -g\nyarn global add typescript\n```\n\n这两个你使用那个都是可以的，根据喜好自行选择，我使用的npm进行安装。\n\n我们在一个目录下新建`Demo1.ts`,输入下面的代码：\n\n```ts\nfunction hello() {\n  let web: string = \"Hello World\";\n  console.log(web);\n}\n\nhello();\n```\n\n使用node Demo1.ts时，会出现报错。所以我们需要先tsc Demo.ts，在目录下将会生成Demo1.js，我们再node Demo1.js就没事了\n\n### 1.1 ts-node 工具\n\n但是这样操作的效率实在是太低了，你可以使用ts-node插件来解决这个问题，有了这个插件，我们就不用再编译了，而使用ts-node就可以直接看到编写结果。\n\n使用`npm`命令来全局安装，直接在命令行输入下面的命令：\n\n```bash\nnpm install -g ts-node\n```\n\n安装完成后，就可以在命令中直接输入如下命令，来查看结果了。\n\n```bash\nts-node Demo1.ts\n```\n\n### Demo1.ts\n\n```ts\nfunction hello() {\n  let web: string = \"Hello World\";\n  console.log(web);\n}\n\nhello();\n```\n\n## 2 Typescript静态类型\n\n### 2.1 一般静态类型\n\n下面的代码是一般的，也是最简单的变量静态类型\n\n```ts\n // 1 一般的静态类型\n const count: number = 1; //此时number这个变量值为0\n```\n这里的: number就是定义了一个静态类型。\n\n这样定义后count这个变量在程序中就永远都是数字类型了，不可以改变了。\n\n比如我们这时候给count复制一个字符串，它就报错了。\n\n```ts\n// 错误示范\nconst count: number = 1\ncount = \"Wibus\"; //这里的代码VSC将会报错提示：Cannot assign to 'count' because it is a constant.（无法分配到 \"count\" ，因为它是常数。）\n```\n\n你也可以发现这时候的count变量,可以使用number类型上所有的属性和方法。\n\n当然我们还可以使用其他的类型，如string（字符串）\n\n### 2.2 自定义静态类型\n\n下面的代码展示了什么是 自定义静态类型\n\n```ts\n//2 自定义静态类型\ninterface Student {\n  name: string; //string - 字符串;\n  age: number; //number 常数\n}\nconst Ming: Student = {\n  name: \"小明\", //可以填写字符串\n  age: 14, //只能填写数字\n};\n```\n\n`interface` 是我们之后需要学到的接口，这部分暂时不说\n\n这时候你如果声明变量，跟自定义不一样，VSCode直接就会报错。需要注意的是，这时候Ming变量也具有name和age属性了。\n\n你需要记住的是，如果使用了静态类型，不仅意味着变量的类型不可以改变，还意味着类型的属性和方法也跟着确定了。这个特点就大大提高了程序的健壮性，并且编辑器这时候也会给你很好的语法提示，加快了你的开发效率。\n\n### Demo2.ts\n\n```ts\n/**\n * Demo2.ts\n * 介绍typescript的静态类型\n * @date 2021-1-1\n * @author Wibus\n */\n\n // 1 一般的静态类型\n const count: number = 1; //此时number这个变量值为0\n\n/**\n  * 这里的: number就是定义了一个静态类型。\n  * 这样定义后count这个变量在程序中就永远都是数字类型了，不可以改变了。\n  * 比如我们这时候给count复制一个字符串，它就报错了。\n  * count = \"Wibus\";\n  */\n\ncount = \"Wibus\"; //这里的代码VSC将会报错提示：Cannot assign to 'count' because it is a constant.（无法分配到 \"count\" ，因为它是常数。）\n\n//2 自定义静态类型\ninterface Student {\n  name: string; //String - 字符串;\n  age: number; //number 常数\n}\nconst Ming: Student = {\n  name: \"小明\", //可以填写字符串\n  age: 14, //只能填写数字\n};\n//这时候你如果声明变量，跟自定义不一样，VSCode直接就会报错。需要注意的是，这时候Ming变量就变得具有name和age属性了\n\n/**\n * 如果使用了静态类型，不仅意味着变量的类型不可以改变，还意味着类型的属性和方法也跟着确定了。\n * 这个特点就大大提高了程序的健壮性，并且编辑器这时候也会给你很好的语法提示，加快了你的开发效率。\n */\n```\n\n## 3 Typescript 基础静态类型和对象类型\n\n在 TypeScript 静态类型分为两种，一种是基础静态类型，一种是对象类型\n\n### 3.1 基础静态类型\n\n基础静态类型非常的简单，只需要在变量名后加上 *:* 之后加上类型名即可，例子如下：\n\n```ts\nconst counter : number = 918; // 类型 number only数字\nconst myName : string = \"Wibus\"; // 类型 string only字符串\n```\n\n类型不止这些，还有`null`,`undefinde`,`symbol`,`boolean`，`void`，`nerver`这些都是最常用的基础数据类型\n\n### 3.2 对象类型\n\n先来看一个例子，通过例子有经验的小伙伴就知道个大概了，然后我们再来讲解(其实上节课我们也讲到了，我们这里就当复习了)。\n\n新建一个文件`demo3.ts`（你可以跟我不一样）,然后写下如下代码。\n\n#### 3.2.1 最简单的对象类型\n```ts\nconst xiaoGeGe: {\n    name: string, //字符串类型\n    age: number, //常数类型\n  } = {\n    name: \"Wibus\", //对应的数据\n    age: 14,\n  };\n  console.log(xiaoGeGe.name);\n```\n\n写完后，我们在 **terminal（终端）** 中输入`ts-node demo3.ts`，可以看到结果输出了Wibus。这就是一个经典的对象类型，也是最简单的对象类型。\n\n#### 3.2.2 数组对象类型\n\n对象类型也可以是数组，比如现在我们需要很多小姐姐，我们就可以这样写。\n\n```ts\nconst xiaoJieJies : string[] = [\"Awa\", \"Qwq\", \"老婆\"];\n```\n\n这时候的意思是，变量xiaoJieJies必须是一个数组，数组里的内容必须是字符串。你可以试着把字符串改为数字，VSCode会直接给我们报错。\n\n```ts\n// ⚠️错误示范\nconst ErrorxiaoJieJies : string[] = [123, \"Qwq\", \"老婆\"]; //VSC将会直接报错\n```\n\n#### 3.2.3 类类型\n\n来看看下面的代码。这个代码就是用类的形式，来定义变量。\n\n```ts\nclass Person {} //定义一个Person类\nconst Js: Person = new Person();\n```\n\n这个意思就是dajiao必须是一个Person类对应的对象才可以。\n\n#### 3.2.4 函数类型\n\n我们还可以定义一个函数类型，并确定返回值。代码如下：\n\n```ts\nconst Wibus : () => string = () => {\n    return \"I'm Wibus\";\n};\n```\n\n我们现在总结一下对象类型可以有几种形式：\n\n- 对象类型\n- 数组类型\n- 类类型\n- 函数类型\n\n这几种形式我们在TypeScript里叫做对象类型。\n\n### Demo3.ts\n\n```ts\n/**\n * Demo3.ts\n * 基础静态类型和对象类型\n * @Date 2021-1-1\n * @author Wibus\n */\n\n\n// 基础静态类型\nconst counter : number = 918;\nconst myName : string = \"Wibus\";\n// null,undefinde,symbol,boolean，void这些都是最常用的基础数据类型\n\n// 对象类型\n// 1 🌰\nconst xiaoGeGe: {\n    name: string, //字符串类型\n    age: number, //常数类型\n  } = {\n    name: \"Wibus\", //对应的数据\n    age: 14,\n  };\n  console.log(xiaoGeGe.name);\n// ts-node Demo3.ts Result: Wibus\n// 这就是一个经典的对象类型，也是最简单的对象类型。\n\n// 2 🌰 对象类型也可以是数组\nconst xiaoJieJies : string[] = [\"Awa\", \"Qwq\", \"老婆\"]; \n// 这时候的意思是，变量xiaoJieJies必须是一个数组，数组里的内容必须是字符串。你可以试着把字符串改为数字，VSCode会直接给我们报错。\n// ⚠️错误示范\nconst ErrorxiaoJieJies : string[] = [123, \"Qwq\", \"老婆\"]; //VSC将会直接报错\n\n// 3 类\n\nclass Person {} //定义一个Person类\nconst Js: Person = new Person(); // 这个意思就是Js必须是一个Person类对应的对象才可以\n// 我们还可以定义一个函数类型，并确定返回值\nconst Wibus : () => string = () => {\n    return \"I'm Wibus\";\n};\n/**\n * 对象类型可以有几种形式：\n * 对象类型\n * 数组类型\n * 类类型\n * 函数类型\n * 这几种形式在TypeScript里叫做对象类型。\n */\n```"},{"title":"Wiather - 一款高德天气插件","slug":"wiather","created":"2020-12-27T11:32:39.373Z","modified":"2020-12-27T11:32:39.365Z","content":"\n\n## 插件信息\n\n插件名称：`Wiather`\n\n作者：<a class=\"Pshake\">Wibus</a>\n\n参照项目：AliceStyle\n\n插件最新版本：`V3.1.0`\n\n## 食用方法\n\n首先，先去GitHub将代码下载下来，解压后修改文件夹名字为`Wiather`，启动插件即可\n**但是启动插件后请先进入插件设置界面点击保存设置一次**\n\nhttps://github.com/wibus-wee/Typecho-Plugin-Wiather GitHub 下载\n\n## 插件特点\n\n![自带检测更新机制](https://gitee.com/wibus/blog-assets-goo/raw/master/asset-pic/plugin-setting-1.jpg)\n![多种自定义设置](https://gitee.com/wibus/blog-assets-goo/raw/master/asset-pic/plugin-setting-2.jpg)\n\n## 插件弹窗样式\n\n![原生alert弹窗](https://gitee.com/wibus/blog-assets-goo/raw/master/asset-pic/2020-12-5-alert.jpg)\n![handsome自带弹窗](https://gitee.com/wibus/blog-assets-goo/raw/master/asset-pic/2020-12-5-handsome-alert.jpg)\n![Sweetalert2](https://gitee.com/wibus/blog-assets-goo/raw/master/asset-pic/2020-12-5-sweet-alert.jpg)\n\n图标样式自行探究吧\n\n### 备用的API\n由**茶栀**提供\n\n```TXT\naaaf9a955be7212018298757655229eb\n```\n\n### 当启动插件发现TTFB变长的问题时\n\n请考虑使用Wiather特别版本（此版本最新只到1.2.0）\n\n此版本不放在GitHub中，放在本博客的第二网盘中\n\n> 已经不再提供使用\n\n新版本插件目录下的文件：\n\n```tree\n.\n├── Plugin.php\n└── static\n    └── libs\n        └── jquery-3.5.1.min.js\n```\n\n## 开发日志\n\n2020-12-5 \n\n新增了一种弹窗样式\n\n正在准备一个自定义功能（作为彩蛋放入插件中，可以在插件设置界面找找彩蛋 ::QQe:qq+1:: \n\n2020-11-24 \n\n新增检测更新机制\n\n新增了一种handsome弹窗图标样式\n\n修复在handsome主题中不启动主题自带弹窗而导致的错误\n\n适配了低版本Typecho版本"},{"title":"Mix 短代码介绍","slug":"mix-shortcode","created":"2020-12-27T07:12:47.461Z","modified":"2020-12-27T07:27:19.635Z","content":"\n\n## `[scode type=\"类型\"]文字内容[/scode]`\n\n你要做的就是修改type=\"\"里的类型即可～\n\n使用的是已经开源了的Super_Code，GitHub：https://github.com/wibus-wee/Super-Code\n\n样式可以看这里：https://mix.iucky.cn/index.php/archives/205/\n\n### $type 参数\n\n|中文名|替换名|\n|:--|:--|\n|黄色|\tyellow|\n|红色|\tred|\n|蓝色|\tlblue|\n|绿色|\tgreen|\n|紫色|\tshare|\n|粉红|\tpink|\n|粉红-pro|\tpink-pro|\n|深邃黑|\tblack|\n|梦幻紫|\tmhz|\n|西瓜红|\txgh|\n|天空之境|\ttkzj|\n|优雅紫|\tyyz|\n|小太阳|\txty|\n|小宇宙|\txyz|\n|橄榄绿|\tgll|\n\n### 例子🌰\n\n`[scode type=\"tkzj\"]天空之境样式[/scode]`"},{"title":"Typecho实现短代码功能","slug":"typecho-shortcode","created":"2020-12-27T00:55:56.054Z","modified":"2020-12-27T06:57:23.417Z","content":"\n\n这里用回复可见做🌰\n\n## 替换文章输出\n\n将post.php中的`<?php $this->content(); ?>`换成\n```php\n<?php\n$db = Typecho_Db::get();\n$sql = $db->select()->from('table.comments')\n    ->where('cid = ?',$this->cid)\n    ->where('mail = ?', $this->remember('mail',true))\n    ->where('status = ?', 'approved')\n//只有通过审核的评论才能看回复可见内容\n    ->limit(1);\n$result = $db->fetchAll($sql);\n\nif($this->user->hasLogin() || $result) {\n    $content = preg_replace(\"/\\[hide\\](.*?)\\[\\/hide\\]/sm\",'<div class=\"reply2view\">$1</div>',$this->content);\n}\nelse{\n    $content = preg_replace(\"/\\[hide\\](.*?)\\[\\/hide\\]/sm\",'<div class=\"reply2view\">此处内容需要评论回复后方可阅读。</div>',$this->content);\n}\necho $content \n\n?>\n```\n\n当然你也可以像我那样，新建一个类，使用`<?php YourClass::Name(); ?>`\n\n```php\nclass Content{\n\n    /**\n     * 替换文章输出实现短代码功能\n     * Author：Wibus\n     * Date：12-27\n     */\n\n    function echoSomeFunny(){\n    \n            $db = Typecho_Db::get();\n        $sql = $db->select()->from('table.comments')\n            ->where('cid = ?',$this->cid)\n            ->where('mail = ?', $this->remember('mail',true))\n            ->where('status = ?', 'approved')\n        //只有通过审核的评论才能看回复可见内容\n            ->limit(1);\n        $result = $db->fetchAll($sql);\n\n        if($this->user->hasLogin() || $result) {\n            $content = preg_replace(\"/\\[hide\\](.*?)\\[\\/hide\\]/sm\",'<div class=\"reply2view\">$1</div>',$this->content);\n        }\n        else{\n            $content = preg_replace(\"/\\[hide\\](.*?)\\[\\/hide\\]/sm\",'<div class=\"reply2view\">此处内容需要评论回复后方可阅读。</div>',$this->content);\n        }\n        echo $content;\n    }\n}\n```\n\n那么就是将post.php中的`<?php $this->content(); ?>`换成`<?php Content::echoSomeFunny();`\n\n## 解决feed暴露\n\n解决缩略内容和feed暴露问题。\n\n在functions.php中加入如下代码即可\n```php\nTypecho_Plugin::factory('Widget_Abstract_Contents')->excerptEx = array('myyodux','one');\nTypecho_Plugin::factory('Widget_Abstract_Contents')->contentEx = array('myyodux','one');\nclass myyodux {\n    public static function one($con,$obj,$text)\n    {\n      $text = empty($text)?$con:$text;\n      if(!$obj->is('single')){\n      $text = preg_replace(\"/\\[hide\\](.*?)\\[\\/hide\\]/sm\",'',$text);\n      }\n      \n               return $text;\n}\n}\n```\n\n就是用插件接口，在缩略内容输出之前，隐藏掉或者替换掉回复可见内容，同时使用if判断，来针对非single页面进行隐藏。\n\n## 使用方法\n\n在写文章需要隐藏部分内容时用以下写法\n\n`[hide]要隐藏的内容[/hide]`\n\n> 不过这个方法会有一个问题：你只能有一个短代码，所以需要找到其他的方法\n\n---\n\n## 后续解决\n\n后来翻找了一下Wordpress程序以及handsome主题，解决了问题\n\n```php\n\n    /**\n     * 短代码模块\n     * Author：Wibus\n     * 参照项目：Wordpress handsome\n     * Date：2020-12-27\n     * 相关function：\n     * get_shortcode_regex，shortcode_parse_atts，get_shortcode_atts_regex，get_markdown_regex，scodeParseCallback，parseContentPublic，postContent，postContentHtml\n     */\n\n    /**\n     * 获取匹配短代码的正则表达式\n     * Date: 2020-12-27\n     * @param null $tagnames\n     * @return string\n     * @link https://github.com/WordPress/WordPress/blob/master/wp-includes/shortcodes.php#L254\n     */\n    public static function get_shortcode_regex($tagnames = null)\n    {\n        global $shortcode_tags;\n        if (empty($tagnames)) {\n            $tagnames = array_keys($shortcode_tags);\n        }\n        $tagregexp = join('|', array_map('preg_quote', $tagnames));\n        // WARNING! Do not change this regex without changing do_shortcode_tag() and strip_shortcode_tag()\n        // Also, see shortcode_unautop() and shortcode.js.\n        // phpcs:disable Squiz.Strings.ConcatenationSpacing.PaddingFound -- don't remove regex indentation\n        return\n            '\\\\['                                // Opening bracket\n            . '(\\\\[?)'                           // 1: Optional second opening bracket for escaping shortcodes: [[tag]]\n            . \"($tagregexp)\"                     // 2: Shortcode name\n            . '(?![\\\\w-])'                       // Not followed by word character or hyphen\n            . '('                                // 3: Unroll the loop: Inside the opening shortcode tag\n            . '[^\\\\]\\\\/]*'                   // Not a closing bracket or forward slash\n            . '(?:'\n            . '\\\\/(?!\\\\])'               // A forward slash not followed by a closing bracket\n            . '[^\\\\]\\\\/]*'               // Not a closing bracket or forward slash\n            . ')*?'\n            . ')'\n            . '(?:'\n            . '(\\\\/)'                        // 4: Self closing tag ...\n            . '\\\\]'                          // ... and closing bracket\n            . '|'\n            . '\\\\]'                          // Closing bracket\n            . '(?:'\n            . '('                        // 5: Unroll the loop: Optionally, anything between the opening and closing shortcode tags\n            . '[^\\\\[]*+'             // Not an opening bracket\n            . '(?:'\n            . '\\\\[(?!\\\\/\\\\2\\\\])' // An opening bracket not followed by the closing shortcode tag\n            . '[^\\\\[]*+'         // Not an opening bracket\n            . ')*+'\n            . ')'\n            . '\\\\[\\\\/\\\\2\\\\]'             // Closing shortcode tag\n            . ')?'\n            . ')'\n            . '(\\\\]?)';                          // 6: Optional second closing brocket for escaping shortcodes: [[tag]]\n        // phpcs:enable\n    }\n    /**\n     * 获取短代码属性数组\n     * Date: 2020-12-27\n     * @param $text\n     * @return array|string\n     * @link https://github.com/WordPress/WordPress/blob/master/wp-includes/shortcodes.php#L508\n     */\n    public static function shortcode_parse_atts($text)\n    {\n        $atts = array();\n        $pattern = self::get_shortcode_atts_regex();\n        $text = preg_replace(\"/[\\x{00a0}\\x{200b}]+/u\", ' ', $text);\n        if (preg_match_all($pattern, $text, $match, PREG_SET_ORDER)) {\n            foreach ($match as $m) {\n                if (!empty($m[1])) {\n                    $atts[strtolower($m[1])] = stripcslashes($m[2]);\n                } elseif (!empty($m[3])) {\n                    $atts[strtolower($m[3])] = stripcslashes($m[4]);\n                } elseif (!empty($m[5])) {\n                    $atts[strtolower($m[5])] = stripcslashes($m[6]);\n                } elseif (isset($m[7]) && strlen($m[7])) {\n                    $atts[] = stripcslashes($m[7]);\n                } elseif (isset($m[8]) && strlen($m[8])) {\n                    $atts[] = stripcslashes($m[8]);\n                } elseif (isset($m[9])) {\n                    $atts[] = stripcslashes($m[9]);\n                }\n            }\n            // Reject any unclosed HTML elements\n            foreach ($atts as &$value) {\n                if (false !== strpos($value, '<')) {\n                    if (1 !== preg_match('/^[^<]*+(?:<[^>]*+>[^<]*+)*+$/', $value)) {\n                        $value = '';\n                    }\n                }\n            }\n        } else {\n            $atts = ltrim($text);\n        }\n        return $atts;\n    }\n\n    /**\n     * Retrieve the shortcode attributes regex.\n     * Date: 2020-12-27\n     * @return string The shortcode attribute regular expression\n     * @since 4.4.0\n     *\n     */\n    public static function get_shortcode_atts_regex()\n    {\n        return '/([\\w-]+)\\s*=\\s*\"([^\"]*)\"(?:\\s|$)|([\\w-]+)\\s*=\\s*\\'([^\\']*)\\'(?:\\s|$)|([\\w-]+)\\s*=\\s*([^\\s\\'\"]+)(?:\\s|$)|\"([^\"]*)\"(?:\\s|$)|\\'([^\\']*)\\'(?:\\s|$)|(\\S+)(?:\\s|$)/';\n    }\n\n    public static function get_markdown_regex($tagName = '?')\n    {\n        return '\\\\' . $tagName . '&gt; (.*)(\\n\\n)?';\n\n    }\n\n    /**\n     * 短代码解析正则替换回调函数\n     * Date: 2020-12-27\n     * Style: Super_Code\n     * @param $matches\n     * @return bool|string\n     */\n    public static function scodeParseCallback($matches)\n    {\n        // 不解析类似 [[player]] 双重括号的代码\n        if ($matches[1] == '[' && $matches[6] == ']') {\n            return substr($matches[0], 1, -1);\n        }\n        //[scode type=\"share\"]这是灰色的短代码框，常用来引用资料什么的[/scode]\n        $attr = htmlspecialchars_decode($matches[3]);//还原转义前的参数列表\n        $attrs = self::shortcode_parse_atts($attr);//获取短代码的参数\n        $type = \"info\";\n        switch (@$attrs['type']) {\n            case 'yellow':\n                $type = \"Scode-Yellow\";\n                break;\n            case 'red':\n                $type = \"Scode-Red\";\n                break;\n            case 'lblue':\n                $type = \"Scode-Blue\";\n                break;\n            case 'green':\n                $type = \"Scode-Green\";\n                break;\n            case 'share':\n                $type = \"Scode-zise\";\n                break;\n            case 'pink':\n                $type = \"Scode-Pink\";\n                break;\n            case 'pink-pro':\n                $type = \"Scode-Pink-Pro\";\n                break;\n            case 'black':\n                $type = \"Scode-Black\";\n                break;\n            case 'mhz':\n                $type = \"Scode-mhz\";\n                break;\n            case 'xgh':\n                $type = \"Scode-xgh\";\n                break;\n            case 'tkzj':\n                $type = \"Scode-tkzj\";\n                break;\n            case 'xyz':\n                $type = \"Scode-xyz\";\n                break;\n            case 'gll':\n                $type = \"Scode-gll\";\n                break;\n            case 'xty':\n                $type = \"Scode-xty\";\n                break;\n            case 'Shadow':\n                $type = \"Shadow\";\n                break;\n            \n        }\n        return '<div class=\" ' . $type . '\">'.\"\\n\\n\" . $matches[5] . \"\\n\".'</div>';\n    }\n\n    /**\n     * 文章解析函数\n     * Date: 2020-12-27\n     * @param $content\n     * @return null|string|string[]\n     */\n    public static function parseContentPublic($content)\n    {\n        //解析短代码功能\n        if (strpos($content, '[scode') !== false) {//提高效率，避免每篇文章都要解析\n            $pattern = self::get_shortcode_regex(array('scode'));\n            $content = preg_replace_callback(\"/$pattern/\", array('Content', 'scodeParseCallback'),\n                $content);\n        }\n        \n        return $content;\n    }\n\n    /**\n     * 替换+输出文章内容\n     * Date: 2020-12-27\n     *\n     * @param $obj\n     * @param $status\n     * @param string $way\n     * @return string\n     */\n    public static function postContent($obj, $status, $way = \"origin\")\n    {\n        if ($way == \"origin\") {\n            $content = $obj->content;\n        } else {\n            $content = $obj->content;\n\n            $content = Content::parseContentPublic($content);\n        }\n        return trim($content);\n    }\n\n    public static function postContentHtml($obj, $status)\n    {\n\n        //$way = \"origin\";\n        \n        $content = Content::postContent($obj, $status, $way);\n        \n        echo $content;\n\n    }\n```\n\n其中，get_shortcode_regex，shortcode_parse_atts，get_shortcode_atts_regex，get_markdown_regex都是wp里的东西\n\n剩下的就是用来替换的了，注释应该都写的挺清楚的了吧？\n\n### 调用方法\n\n将post.php里的`<?php $this->content(); ?>`替换为`<?php Content::postContentHtml($this,$this->user->hasLogin()); ?>·`"},{"title":"Neuomorphic Keyboard","slug":"neuomorphic-keyboard","created":"2020-12-26T15:52:05.720Z","modified":"2021-01-03T14:28:26.006Z","content":"\n\n> 新拟物化设计\n> Writer: Braydon Coyer\n\n## HTML实现\n\n```html\n<div class=\"container\">\n  <div class=\"textbox__container\">\n    <textarea autofocus name=\"textbox\" cols=\"128\" rows=\"10\" class=\"textbox\" placeholder=\"Start typing on your keyboard to see the neuomorphic keyboard react...\"></textarea>\n  </div>\n  <div class=\"container__content\">\n    <div class=\"keyboard\">\n    <div class=\"keyboard__row\">\n      <div class=\"keyboard__keys\">\n        <span class=\"key\"><p class=\"key__letter\">Q</p></span>\n        <span class=\"key\"><p class=\"key__letter\">W</p></span>\n        <span class=\"key\"><p class=\"key__letter\">E</p></span>\n        <span class=\"key\"><p class=\"key__letter\">R</p></span>\n        <span class=\"key\"><p class=\"key__letter\">T</p></span>\n        <span class=\"key\"><p class=\"key__letter\">Y</p></span>\n        <span class=\"key\"><p class=\"key__letter\">U</p></span>\n        <span class=\"key\"><p class=\"key__letter\">I</p></span>\n        <span class=\"key\"><p class=\"key__letter\">O</p></span>\n        <span class=\"key\"><p class=\"key__letter\">P</p></span>\n      </div>\n    </div>\n    <div class=\"keyboard__row\">\n      <div class=\"keyboard__keys\">\n        <span class=\"key\"><p class=\"key__letter\">A</p></span>\n        <span class=\"key\"><p class=\"key__letter\">S</p></span>\n        <span class=\"key\"><p class=\"key__letter\">D</p></span>\n        <span class=\"key\"><p class=\"key__letter\">F</p></span>\n        <span class=\"key\"><p class=\"key__letter\">G</p></span>\n        <span class=\"key\"><p class=\"key__letter\">H</p></span>\n        <span class=\"key\"><p class=\"key__letter\">J</p></span>\n        <span class=\"key\"><p class=\"key__letter\">K</p></span>\n        <span class=\"key\"><p class=\"key__letter\">L</p></span>\n      </div>\n    </div>\n    <div class=\"keyboard__row\">\n      <div class=\"keyboard__keys\">\n         <span class=\"key\"><p class=\"key__letter\">Z</p></span>\n        <span class=\"key\"><p class=\"key__letter\">X</p></span>\n        <span class=\"key\"><p class=\"key__letter\">C</p></span>\n        <span class=\"key\"><p class=\"key__letter\">V</p></span>\n        <span class=\"key\"><p class=\"key__letter\">B</p></span>\n        <span class=\"key\"><p class=\"key__letter\">N</p></span>\n        <span class=\"key\"><p class=\"key__letter\">M</p></span>\n      </div>\n    </div>\n  <div class=\"keyboard__row\">\n    <div class=\"keyboard__keys\">\n      <span class=\"key key__space\"><p class=\"key__letter\">Space</p></span>\n    </div>\n  </div>\n</div>\n  </div>\n</div>\n\n```\n\n## CSS实现\n\n> 这里使用了SCSS，据我所知，和css有点不一样的\n\n```scss\n@import url('https://fonts.googleapis.com/css?family=Ubuntu:500&display=swap');\n\n$primary-color: #F2F7FB;\n$key-corner: #E9F2FB;\n$shadow-color: #D9E3EC;\n\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n  font-family: 'Ubuntu', sans-serif;\n}\n\nbody {\n  background: $primary-color;\n}\n\n.container {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  min-height:100vh;\n  flex-direction: column;\n  \n  &__content {\n    width: 60%;\n  }\n}\n\n.textbox {\n  width: 100%;\n  resize: none;\n  background: linear-gradient(145deg, $primary-color, $key-corner);\n  box-shadow:  inset 8px 8px 15px $shadow-color;\n  border-radius: 12px;\n  border: none;\n  overflow: auto;\n  padding: 20px;\n  outline: none;\n  margin: 50px 0;\n}\n\n.keyboard {\n  padding: 25px;\n  background: linear-gradient(145deg, $primary-color, $key-corner);\n  box-shadow:  8px 8px 15px $shadow-color;\n  border-radius: 12px;\n  min-width: 750px;\n  max-width: 1000px;\n  \n  &__keys {\n    display: flex;\n    justify-content: center;\n  }\n  \n}\n\n.key { \n  display: flex;\n \n  justify-content: center;\n  align-items: center;\n  padding:10px;\n  margin: 10px;\n  min-width: 50px;\n  height: 50px;\n  border-radius: 15px;\n  background: linear-gradient(145deg, $primary-color, $key-corner);\n  box-shadow:  5px 5px 15px $shadow-color;\n  \n  &__letter {\n    background: -webkit-linear-gradient(245deg, #1E71F5, #3CDEE7);\n    -webkit-background-clip: text;\n    -webkit-text-fill-color: transparent;\n  }\n  \n  &__down {\n    color: linear-gradient(45deg, #1E71F5, #3CDEE7);;\n    background: linear-gradient(145deg, $key-corner,  $primary-color);\n    box-shadow:  inset 5px 5px 5px $shadow-color;\n  }\n  \n  &__space {\n    width: 60%;\n  }\n}\n```\n\n## JavaScript实现\n\n```javascript\nconst kd = document.querySelectorAll(\".key\");\nconst textbox = document.querySelector(\".textbox\");\n\nlet keyPressed = (e) => {\n  let kc = e.keyCode;\n\n    if ( (kc >= 65 && kc <= 90) || kc == 32) {\n        if (kc == 81) { kd[0].classList.add(\"key__down\"); }\n        else if (kc == 87) { kd[1].classList.add(\"key__down\"); }\n        else if (kc == 69) { kd[2].classList.add(\"key__down\"); }\n        else if (kc == 82) { kd[3].classList.add(\"key__down\"); }\n        else if (kc == 84) { kd[4].classList.add(\"key__down\"); }\n        else if (kc == 89) { kd[5].classList.add(\"key__down\"); }\n        else if (kc == 85) { kd[6].classList.add(\"key__down\"); }\n        else if (kc == 73) { kd[7].classList.add(\"key__down\"); }\n        else if (kc == 79) { kd[8].classList.add(\"key__down\"); }\n        else if (kc == 80) { kd[9].classList.add(\"key__down\"); }\n        else if (kc == 65) { kd[10].classList.add(\"key__down\"); }\n        else if (kc == 83) { kd[11].classList.add(\"key__down\"); }\n        else if (kc == 68) { kd[12].classList.add(\"key__down\"); }\n        else if (kc == 70) { kd[13].classList.add(\"key__down\"); }\n        else if (kc == 71) { kd[14].classList.add(\"key__down\"); }\n        else if (kc == 72) { kd[15].classList.add(\"key__down\"); }\n        else if (kc == 74) { kd[16].classList.add(\"key__down\"); }\n        else if (kc == 75) { kd[17].classList.add(\"key__down\"); }\n        else if (kc == 76) { kd[18].classList.add(\"key__down\"); }\n        else if (kc == 90) { kd[19].classList.add(\"key__down\"); }\n        else if (kc == 88) { kd[20].classList.add(\"key__down\"); }\n        else if (kc == 67) { kd[21].classList.add(\"key__down\"); }\n        else if (kc == 86) { kd[22].classList.add(\"key__down\"); }\n        else if (kc == 66) { kd[23].classList.add(\"key__down\"); }\n        else if (kc == 78) { kd[24].classList.add(\"key__down\"); }\n        else if (kc == 77) { kd[25].classList.add(\"key__down\"); }\n        else if (kc == 32) {\n            kd[26].classList.add(\"key__down\");\n            textbox.innerHTML += \"&nbsp;\";\n        }\n    }\n}\n\nlet keyReleased = (e) => {\n   let kc = e.keyCode;\n  if (kc == 81) { kd[0].classList.remove(\"key__down\"); }\n        else if (kc == 87) { kd[1].classList.remove(\"key__down\"); }\n        else if (kc == 69) { kd[2].classList.remove(\"key__down\"); }\n        else if (kc == 82) { kd[3].classList.remove(\"key__down\"); }\n        else if (kc == 84) { kd[4].classList.remove(\"key__down\"); }\n        else if (kc == 89) { kd[5].classList.remove(\"key__down\"); }\n        else if (kc == 85) { kd[6].classList.remove(\"key__down\"); }\n        else if (kc == 73) { kd[7].classList.remove(\"key__down\"); }\n        else if (kc == 79) { kd[8].classList.remove(\"key__down\"); }\n        else if (kc == 80) { kd[9].classList.remove(\"key__down\"); }\n        else if (kc == 65) { kd[10].classList.remove(\"key__down\"); }\n        else if (kc == 83) { kd[11].classList.remove(\"key__down\"); }\n        else if (kc == 68) { kd[12].classList.remove(\"key__down\"); }\n        else if (kc == 70) { kd[13].classList.remove(\"key__down\"); }\n        else if (kc == 71) { kd[14].classList.remove(\"key__down\"); }\n        else if (kc == 72) { kd[15].classList.remove(\"key__down\"); }\n        else if (kc == 74) { kd[16].classList.remove(\"key__down\"); }\n        else if (kc == 75) { kd[17].classList.remove(\"key__down\"); }\n        else if (kc == 76) { kd[18].classList.remove(\"key__down\"); }\n        else if (kc == 90) { kd[19].classList.remove(\"key__down\"); }\n        else if (kc == 88) { kd[20].classList.remove(\"key__down\"); }\n        else if (kc == 67) { kd[21].classList.remove(\"key__down\"); }\n        else if (kc == 86) { kd[22].classList.remove(\"key__down\"); }\n        else if (kc == 66) { kd[23].classList.remove(\"key__down\"); }\n        else if (kc == 78) { kd[24].classList.remove(\"key__down\"); }\n        else if (kc == 77) { kd[25].classList.remove(\"key__down\"); }\n        else if (kc == 32) { kd[26].classList.remove(\"key__down\"); }\n}\n\n\nwindow.addEventListener(\"keydown\", keyPressed);\nwindow.addEventListener(\"keyup\", keyReleased);\n// window.onload = () => {\n//   document.querySelector(\".textbox\").focus();\n// }\n\n```\n\n<button onclick=\"document.body.contentEditable='true'\">点击这里开始装逼模式</button>"},{"title":"Super Code UI","slug":"super-code-ui","created":"2020-12-26T08:17:23.206Z","modified":"2020-12-27T04:53:37.933Z","content":"\n\n##  Super Code UI \n\n- 14 built-in code box styles\n- Two series\n- Just introduce a CSS\n- The global general\n\n## 🎂 How To Use\n\nDownload `Super_Code_UI.css` into your server\n\nPut into root dir, and put code into your html: \n\n```html\n<link rel=\"stylesheet\" href=\"Super_Code_UI.css\">\n```\n\nEnjoy! \n\n## 🌯 Example\n\nMy Typecho-Theme: Mix uses this css.\n\nHere is My Theme: https://mix.iucky.cn\n\n\n```html\n<div class=\"Scode-Black\">Here is Scode-Black, Maybe used in ?</div>\n<div class=\"Scode-Blue\">Here is Scode-Blue, Maybe used in ?</div>\n<div class=\"Scode-Red\">Here is Scode-Red, Maybe used in ?</div>\n<div class=\"Scode-Pink\">Here is Scode-Pink, Maybe used in ?</div>\n<div class=\"Scode-Pink-Pro\">Here is Scode-Pink-Pro, Maybe used in ?</div>\n<div class=\"Scode-Green\">Here is Scode-Green, Maybe used in ?</div>\n<div class=\"Scode-zise\">Here is Scode-zise, Maybe used in ?</div>\n<div class=\"Scode-mhz\">Here is Scode-mhz, Maybe used in ?</div>\n<div class=\"Scode-xgh\">Here is Scode-xgh, Maybe used in ?</div>\n<div class=\"Scode-tkzc\">Here is Scode-tkzc, Maybe used in ?</div>\n<div class=\"Scode-xyz\">Here is Scode-xyz, Maybe used in ?</div>\n<div class=\"Scode-gll\">Here is Scode-gll, Maybe used in ?</div>\n<div class=\"Scode-xty\">Here is Scode-xty, Maybe used in ?</div>\n<div class=\"Scode-yyz\">Here is Scode-yyz, Maybe used in ?</div>\n<div class=\"Shadow\">Here is a Shadow Style, Maybe used in ?</div>\n```"},{"title":"Typecho-Plugin-Live2D","slug":"typecho-plugin-live2D","created":"2020-12-26T06:26:44.135Z","modified":"2020-12-26T06:27:40.550Z","content":"\n\n之前爆胎写了一篇博客添加Live2D 看板娘的文章。为了方便大家，直接做成了一个插件\n\n> 来自爆胎文章\n \n\n## 插件\n\n相对于`Paul`的`Pio`插件，简化了很多，并且自动在手机端隐藏（Live2D在手机端显示在百度站长移动落地检测时会检测为广告，并且有很多手机在启动Live2D后明显卡顿）\n\n**插件由**：<a class=\"Pshake\" href=\"https://blog.iucky.cn\">Wibus</a> 制作\n\n请1.1.0以下用户更新至最新版本，新版本加入了检测更新机制，更加方便！\n\n**项目地址**： \n\nhttps://github.com/wibus-wee/Typecho-Plugin-Live2D\n\n \n\n## 使用\n\n下载改名为**Live2D**然后启用就行了，然后选择放在左边还是右边。换装等按钮需要`FontAwesome`支持,如果你的站已经加载了，就不用加载了。\n![img](https://gitee.com/baotai/img/raw/master/img/image-20201019142210321.png)\n\n## 说明\n\n默认加载模型为 `PIO` 老婆，下一版本更新会加入自定义首次加载模型\n![img](https://gitee.com/baotai/img/raw/master/img/photo.png)\n\n## 模型展示\n\n![ ](https://gitee.com/baotai/img/raw/master/img/photo1.png)\n\n![ ](https://gitee.com/baotai/img/raw/master/img/photopio.png)\n\n![ ](https://gitee.com/baotai/img/raw/master/img/photo2.png)\n\n![ ](https://gitee.com/baotai/img/raw/master/img/photo3.png)\n\n![  ](https://gitee.com/baotai/img/raw/master/img/photo4.png)\n\n![ ](https://gitee.com/baotai/img/raw/master/img/photo5.png)\n\n![ ](https://gitee.com/baotai/img/raw/master/img/photo7.png)\n\n\n## 皮肤\n\n- 收集了 bilibili-22 全套皮肤\n- 收集了 bilibili-33 全套皮肤\n- 收集了 Pio 全套皮肤\n- 收集了 Tia 全套皮肤\n- 收集了 ShizukuTalk 2套皮肤\n- 收集了 HyperdimensionNeptunia全套皮肤\n- 收集了 KantaiCollection 1套皮肤"},{"title":"2021跨年Activity！","slug":"2021-new-year","created":"2020-12-20T00:01:23.008Z","modified":"2020-12-25T23:06:32.763Z","content":"\n\n## 2020 Prefect Year！\n\n2020.4.25 第一次接触，在本地安装了里程密博客程序，bug一大堆，搞来搞去不会搞，小白一个无人帮\n\n直到\n\n2020.12.12 开发出了Mix主题\n\n历经`248天`，感觉挺不容易的\n\n## 那么\n\n就让我们来庆祝一下2021元旦吧！\n\n2020年是全面小康的决胜之年，明年将会全面实现小康社会！我们离实现中华民族伟大复兴更近了一步！\n\n> 本次活动持续至2021.1.15～\n\n## 活动一 限量2000台\n\n香港CN2 首月2元起，配置如下：\n\n- CPU1核\t内存1G 数据盘10G 宽带1M 月份2元 年付120元\n- 2核 2G 20G 2M 月7.7 年290\n- 4核 4G 30G 3M 月15.2 年570\n- 4核 8G 60G 3M 月23.2 年870\n\n香港CN2放量2000台售空后，上架美国以及国内价格不变\n\n## 活动二 加购赠送\n\n这波啊肯定是最多人看上了😂\n\n加购赠送海南挂机宝，每天限量赠送\n\n配置：1核(CPU) 1G(内存) 1M(带宽) 10G(磁 盘)\n\n拉人有机会获得永久挂机宝(活动结束抽取拉人最多的赠送)\n\n## 活动三 限量抢购\n\n安徽ECS云服务器独立IP国内全绿!配置表如下：\n\n- 1核(CPU) 2G(内存) 5M(带宽) 10G(磁盘) 10G(防御)仅需6.8元\n\n- 2核(CPU) 4G(内存) 5M(带宽) 10G(磁盘) 10G(防御)仅需12.6元\n\n- 4核(CPU) 4G(内存) 5M(带宽) 10G(磁盘) 10G(防御)仅需17.4元\n\n- 4核(CPU) 8G(内存) 5M(带宽) 10G(磁盘) 10G(防御)仅需28元\n\n> 有要的加我的QQ找我！下面有\n\n## 活动四 终极大餐！\n\n只有8份！先到先得！\n\n*赠送8份免费挂机宝*～\n\n下方评论区申请，到时候随机抽取！\n\n申请格式：\n\n> 名字：Wibus\n>\n> QQ：1596355173\n> \n> 新年祝福语：新年快乐～～～\n\n我会来找你的\n\n活动最终解释权为[游端网络](https://www.xiaoaa.cn/)\n\n感谢[游端网络](https://www.xiaoaa.cn/)对本次活动的大力支持！"},{"title":"Typecho博客加入Pjax","slug":"typecho-add-pjax","created":"2020-12-19T03:12:42.384Z","modified":"2020-12-19T03:17:03.586Z","content":"\n\n## 介绍\n官方介绍：pushState + ajax = pjax 带来最直观的效果是整个网站变成单页应用。这样的效果将会极大的提升用户体验，并且可以减少https的请求的次数和内容。使用github上面的一个开源项目defunkt/jquery-pjax 可以很轻松的帮助我们实现pjax。\n\n> 需要具备基础的html & javascript 知识。如果你连div和script标签仍然不认识，请忽略该篇文章。\n\n## 实现\njs文件引入\n1.引入jquery.min.js,query.pjax.js\n```html\n  <script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js\"></script>\n  <script src=\"https://cdn.bootcdn.net/ajax/libs/jquery.pjax/2.0.1/jquery.pjax.min.js\"></script>\n```\n\n（或者自己下载这个项目里的js https://github.com/defunkt/jquery-pjax 这个项目里面下载里面的jquery.pjax.js）\n\n### 如何使用\n\n在footer.php里面加上这段代码就初步成功。【继续往下看！尤其是container的介绍】\n```html\n<script>\n$(document).pjax(selector, [container], options) \n</script>\n```\n\n`selector` 给哪些selector绑定pjax事件，一般的为：\"a\", 如果要去掉一些外连的URL， 这里的selector可以为:`\"a[href^='https://iucky.cn']\"`\n\n`[container] `内容变换容器，是指哪个容器里的内容发生的变换，如： '#pjax-content'。就是页面中只刷新的这个部分。\n\n`options` 官方文档提供了更多的选项，以便更好地自定义选项。具体查考官方文档。以下列出我使用的一些选项。\n\n`container` 替换的容器的css选择器。填你的替换容器ID即可。\n\n`timeout` 超时就会被迫页面就会完全刷新，单位毫秒。\n\n`fragment` 这个作为整个pjax框架，必须写上。\n\n所以，代码可以这样写\n\n<script>\n$(document).pjax('a[href^=\"<?php Helper::options()->siteUrl()?>\"]:not(a[target=\"_blank\"], a[no-pjax])', {\n    container: '#pjax-container',\n    fragment: '#pjax-container',\n    timeout: 8000\n})\n</script>\n一定要放在jquery.min.js 和 jquery.pjax.min.js 的后面\n\n解释一下上面代码：`<?php Helper::options()->siteUrl()?>`是typecho的自带函数，调用本站的首页地址！也就是只对本站的，并且没有`_blank`属性的，标签里不含**no-pjax**的链接实行pjax！局部刷新的区域是`#pjax-container`的部分！\n\n其中#pjax-container是你的局部刷新部分，你可能没有这个div，你自己在添加一个`<div id=\"pjax-container\"></div>`包裹住你想局部刷新的部分就行了！\n\n## 加载动画\n\npjax项目还提供了一些pjax事件。以便在pjax执行前后加载一些东西。\n\n加载动画只需要使用这两个事件pjax:send和pjax:complete\n\n如我之前写的：\n\n```html\n<script>\n$(document).on('pjax:send',\nfunction() {\n    $('#loader-wrapper').addClass(\"in\");\n})\n\n$(document).on('pjax:complete',\nfunction() {\n    $('#loader-wrapper').removeClass(\"in\");\n}）\n</script>\n```\n\n解释一下上面代码：就是在pjax执行开始的时候，给#loader-wrapper加上in的样式名称。在pjax结束的时候给给#loader-wrapper去掉in的样式名称，这样就有了加载出现动画，加载后动画消失的效果。\n\n我目前正在开发的主题\"Mix\"使用的加载动画来自这儿：nprogress：http://ricostacruz.com/nprogress/\n\n### 引入nprogress\n\n和引入jquery一样，放在header或者footer，一般是放在jquery的下面的\n\n```html\n<script src=\"https://cdn.bootcdn.net/ajax/libs/nprogress/0.2.0/nprogress.min.js\"></script>\n<link href=\"https://cdn.bootcdn.net/ajax/libs/nprogress/0.2.0/nprogress.min.css\" rel=\"stylesheet\">\n```\n\nnprogress使用起来更简单。在pjax:send的事件里面添加：`NProgress.start();` .在pjax:complete的事件里面添加：`NProgress.done();`\n\n更多使用方法点开链接，看一下github的说明就行！\n\n## 一些问题的解决\n\npjax采用的是异步请求资源，也就是每次请求数据不是重新获取整个页面的数据而是只会获取#pjax-container容器里面的数据。所以如果一个函数在容器外面（如多说加载函数），在A页面没有，B又需要的话，那么从A页面进入B页面，这个函数就不会执行。必须回调这个函数。\n\n注： 不同主题对于#pjax-container选取不一样以及结构可能不同解决方法会有不同（一般是差不多的）\n\n\n### js失效问题\n\n在`pjax:complete`事件 重载相关函数即可。\n\n### 举例\n\n```html\n<script>\n$(document).on('pjax:complete',\nfunction() {\n    GenerateContentList();\n    setupContents();\n    rebindEvents();\n</script>\n```\n所以，最后我的pjax代码就是酱紫的！\n\n```html\n<script>\n//pjax 刷新\n\n$(document).pjax('a[href^=\"<?php Helper::options()->siteUrl()?>\"]:not(a[target=\"_blank\"], a[no-pjax])', {\n    container: '#pjax-container',\n    fragment: '#pjax-container',\n    timeout: 8000\n}).on('pjax:send',\nfunction() {\n    NProgress.start();//加载动画效果开始\n    \n}).on('pjax:complete',\nfunction() {\nNProgress.done();//加载动画效果结束\nimageeffct();//灯箱函数重载\n setupContents();//某个函数重载\nlue();//lue函数重载\nreHighlightCodeBlock();//代码高亮函数重载\n</script>\n```\n\n至此！享受你的pjax无刷新技术吧！"},{"title":"Typecho博客加入PWA","slug":"typecho-add-pwa","created":"2020-12-18T16:05:59.009Z","modified":"2020-12-18T16:06:17.755Z","content":"\n\n## 前言\n\n这次踩了好多坑，有很多篇教程都是一样的，但是又刚刚好似乎是不适配handsome主题，总是出错。之后花了一晚上的时间和我的好朋友 **[霂森西 _ 櫻玲桉](https://dlizi.com/)** 在研究，陪着我搞了很长的时间，感谢~\n\n> 有一点请注意：使用PWA后请不要启动handsome插件自带的**本地离线缓存**功能\n\n其实这个功能就是我们要弄的PWA（但今天我们不去用它）\n\n> 本文参考了https://lzw.me/a/pwa-service-worker.html\n\n## 你需要注意的Service Worker 特点\n\n- 网站**必须使用 HTTPS**。除了使用本地开发环境调试时(如域名使用 `localhost`)\n- 运行于浏览器后台，可以控制打开的作用域范围下所有的页面请求\n- 单独的作用域范围，单独的运行环境和执行线程\n- 不能操作页面 DOM。但可以通过事件机制来处理\n\n## 如何改造？\n\n参考如下步骤为你的博客快速地引入 PWA：1. 添加sw.js 2. 添加offline.html 3. manifest.jsopn 4. 引入 5. 注册sw.js\n\n### 1. 添加sw.js\n\n可以直接参考本站的sw.js https://blog.iucky.cn/sw.js\n\n之后放入网站根目录\n\n### 2. offline.html\n\n设计简单的 `offline.html` 用于离线降级显示。简单的示例参考： `https://blog.iucky.cn/offline.html`\n\n放入网站根目录\n\n### 3. manifest.json\n\n有个注意事项：\n\n需要注意的是，你需要制作一个**256\\*256及以上的ico**，不然将会出现报错，无法成功！\n\n下载本站的json并修改适合你的博客，放到站点根目录（https://blog.iucky.cn/manifest.json）\n\n\n```json\n{\n  \"scope\": \"/\",\n  \"name\": \"秉松博客\",\n  \"short_name\": \"秉松博客\",\n  \"start_url\": \"/\",\n  \"display\": \"standalone\",\n  \"description\": \"有秉性正直的松\",\n  \"dir\": \"rtl\",\n  \"lang\": \"cn\",\n  \"orientation\": \"portrait\",\n  \"theme_color\": \"#fff\",\n  \"background_color\": \"#fff\",\n    \"icons\": [\n        {\n            \"src\": \"https://blog.iucky.cn/favicon-1.ico\",\n            \"sizes\": \"64x64\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"https://blog.iucky.cn/favicon-1.ico\",\n            \"sizes\": \"120x120\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"https://blog.iucky.cn/favicon-1.ico\",\n            \"sizes\": \"144x144\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"https://blog.iucky.cn/favicon-1.ico\",\n            \"sizes\": \"152x152\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"https://blog.iucky.cn/favicon-1.ico\",\n            \"sizes\": \"192x192\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"https://blog.iucky.cn/favicon-1.ico\",\n            \"sizes\": \"384x384\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"https://blog.iucky.cn/favicon-1.ico\",\n            \"sizes\": \"512x512\",\n            \"type\": \"image/png\"\n        }\n    ]\n}\n\n```\n\n### 引入文件以及载入支持\n\n将下面代码放至`自定义输出head 头部的HTML代码`\n\n```html\n<!--PWA（manifest必须加载）-->\n<link rel=\"manifest\" href=\"/manifest.json\">\n<!--PWA（为iOS和Windows10载入支持）-->\n<meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n<meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\">\n<meta name=\"apple-mobile-web-app-title\" content=\"秉松博客\">\n<link rel=\"apple-touch-icon\" href=\"https://blog.iucky.cn/favicon-1.ico\">\n<meta name=\"msapplication-TileImage\" content=\"https://blog.iucky.cn/favicon-1.ico\">\n<meta name=\"msapplication-TileColor\" content=\"#fff\">\n<!--PWA End-->\n```\n\n   \n\n### 注册sw.js\n\n将下面的代码放入`自定义输出body 尾部的HTML代码`\n\n注意先知：\n\n请注意，这串代码中，你需要**修改一处地方**，自己从代码里找下吧\n\n\n```html\n<script>\n// 注册 ServiceWorker\nfunction regSW() {\n    if ('serviceWorker' in navigator) {\n        // 注册\n        navigator.serviceWorker\n            .register('/sw.js', {scope: '/'})\n            .then( function(registration) {\n                console.log('ServiceWorker 注册成功！作用域为: ', registration.scope);\n            })\n            .catch(function(err) {\n                console.log('ServiceWorker 注册失败: ', err);\n            });\n \n        // SW 消息处理\n        navigator.serviceWorker.ready.then(function(reg) {\n            if (!window.Notification || !window.MessageChannel) {\n                return;\n            }\n \n            // 建立一个消息管道，用于当前页面与 SW 之间的消息传递，也便于 SW 知道该消息的来源\n            var channel = new window.MessageChannel();\n \n            channel.port1.onmessage = function(e) {\n                console.log('get Message: ', e.data);\n                if (!e.data) {\n                    return;\n                }\n \n                // 要求申请通知权限\n                if (e.data.type === 'applyNotify') {\n                    window.Notification.requestPermission().then(function(grant) {\n                        if (grant !== 'granted') {\n                            console.log('申请通知权限被拒绝了！')\n                            return;\n                        }\n \n                        reg.active.postMessage({type: 'notify', info: e.data.info}, [channel.port2]);\n                    });\n                }\n            }\n \n            reg.active.postMessage('hello', [channel.port2]);\n        });\n \n        // 掉线通知示例\n        $(window).on('offline', function() {\n            Notification.requestPermission().then(function (grant) {\n                if (grant !== 'granted') {\n                    return;\n                }\n \n                var notification = new Notification(\"Hi，网络不给力哟\", {\n                    body: '您的网络貌似离线了，不过在秉松博客里访问过的页面还可以继续打开~',\n                    icon: 'https://kyun.ltyuanfang.cn/tc/2020/07/30/9b5b630e9860b.png'\n                });\n \n                notification.onclick = function() {\n                    notification.close();\n                };\n            });\n        })\n    }\n}\nregSW();\n</script>\n```\n\n最后，刷新下浏览器缓存，就可以看到效果啦！！\n\n> 成功了的话可以在评论区和我说说呀\n\n## 最后效果\n![](https://kyun.ltyuanfang.cn/tc/2020/11/08/85eae916ec4c0.jpg)"},{"title":"Typecho调用某一分类下的文章","slug":"typecho-use-one-category","created":"2020-12-18T15:41:18.516Z","modified":"2020-12-18T15:41:18.486Z","content":"\n\n根据分类mid获取某个分类下的文章列表\n\n```php\n<?php $this->widget('Widget_Archive@index', 'pageSize=6&type=category', 'mid=1')->to($new); ?>\n<?php while ($new->next()): ?>\n<a href=\"<?php $new->permalink(); ?>\"><?php $new->title(); ?></a>\n<?php endwhile; ?>\n```\n\n以上就是获取分类**mid**等于1的最新6篇文章，`pageSize=6`就是指定调用数量，`mid=1`指定分类**mid**，也可以用缩略名方式替换如`slug=name`其中**name**就是**mid**等于1的分类的缩略名。\n\n如果同一个页面调用多个分类的文章，那么需要上述代码中`@index`的@后面的参数不同，如下面调用mid=1和mid=2两个不同分类的文章\n\n```php\n//分类一\n<?php $this->widget('Widget_Archive@indexa', 'pageSize=6&type=category', 'mid=1')->to($new); ?>\n<?php while ($new->next()): ?>\n<a href=\"<?php $new->permalink(); ?>\"><?php $new->title(); ?></a>\n<?php endwhile; ?>\n\n//分类二\n<?php $this->widget('Widget_Archive@indexb', 'pageSize=6&type=category', 'mid=2')->to($new); ?>\n<?php while ($new->next()): ?>\n<a href=\"<?php $new->permalink(); ?>\"><?php $new->title(); ?></a>\n<?php endwhile; ?>\n```"},{"title":"QEMU-Tool-Box","slug":"qemu-tool-box","created":"2020-12-17T15:09:29.479Z","modified":"2020-12-17T15:10:40.173Z","content":"\n\n> A program that helps users use the QEMU command\n> \n> 一个帮助用户使用QEMU命令的程序\n\n## 关于项目\n\n使用C语言编写，历时几个月\n\n其中包括：学习C语言->了解QEMU命令->编写程序 的时间（还有学业繁忙没有更新的时间）\n\n项目使用了两种方法：`If-else`和`swich-case`（我在这里暂时称为sc版） \n\n由于其复杂，if-else用法已经废除，想去看看的话，也算了吧😂\n\nGitHub仓库：https://github.com/wibus-wee/QEMU-Tool-Box\n\n## 项目开发\nswich-case用法经历了两个时期：无函数->函数控制。\n\n或许用词不是很标准，就是一开始的sc版的大部分代码是通过copy-paste来实现的。但是由于此类代码不好维护，以及可读性感觉不太好，于是定义了一个函数进行输出判断控制\n\n这个项目其实并没有使用其他比较难的东西，只有输入、输出、判断，来来去去也就是scanf, printf, swich-case这三个\n\n代码中或许有一些非常幼稚的想法，或许会有一些完全没有必要但是我还是使用了的方法来实现某个功能的\n\n还请大佬纠错～～\n\n## 编译项目\n\n1. gcc in program's root dir\n    ```bash\n    cd Qemu\\ Tool\\ Box\n    gcc main.c\n    ```\n2. 打开`Qemu Tool Box.xcodeproj`点击run即可\n\n\n## 开发历程\n\n2020.3 开始开发项目\n\n2020.4 学习C语言中……\n\n2020.5 完成基本的判断输出（if-else）\n\n2020.6 废除if-else，转用swich-case语句\n\n2020.7～10 上学学业繁忙，并没有顾及此项目了\n\n2020.11 使用了函数控制，代码维护性增加\n\n2020.12.6 建立GitHub仓库"},{"title":"PHP解析JSON","slug":"php-parsing-json","created":"2020-12-13T14:47:41.150Z","modified":"2020-12-18T15:36:27.803Z","content":"\n\n## 思路\n\n先给一个变量放json的内容，之后再用另一个变量让json转存为数组,再用其他输出一下就就好了\n\n> 在`Mix`主题中使用了\n\n## 一般情况实现\n\n```php\n/*\n * 解析MoreJSON信息\n * Used In Theme: Mix\n * Author: Wibus\n * 相关变量：$MoreJsonName $MoreJsonLink $MoreJsonMore\n * Date：2020.12.13\n */\n\n$morejson = '{\"Name1\": \"关于\", \"Link1\": \"https://iucky.cn/about\",\"More1\": \"关于我的一切\",\"Name2\": \"留言\", \"Link2\": \"https://iucky.cn/message\",\"More2\": \"留言刷刷走起来\", \"Name3\": \"Mix-space\", \"Link3\": \"https://iucky.cn/mix-space\", \"More3\": \"Mix-Space使用文档\",\"Name4\": \"订阅\", \"Link4\": \"https://iucky.cn/feed\",\"More4\": \"来份订阅很不错！\"}'; //修改morejson里的内容即可\n$MoreJson = json_decode($morejson); //json转存为数组\n$MoreJsonName1 = $MoreJson->{'Name1'};\n$MoreJsonLink1 = $MoreJson->{'Link1'};\n$MoreJsonMore1 = $MoreJson->{'More1'};\n\n$MoreJsonName2 = $MoreJson->{'Name2'};\n$MoreJsonLink2 = $MoreJson->{'Link2'};\n$MoreJsonMore2 = $MoreJson->{'More2'};\n\n$MoreJsonName3 = $MoreJson->{'Name3'};\n$MoreJsonLink3 = $MoreJson->{'Link3'};\n$MoreJsonMore3 = $MoreJson->{'More3'};\n\n$MoreJsonName4 = $MoreJson->{'Name4'};\n$MoreJsonLink4 = $MoreJson->{'Link4'};\n$MoreJsonMore4 = $MoreJson->{'More4'};\n\n```\n\n先用了`$morejson`储存json数据，之后使用`json_decode($morejson)`对这个json进行处理，再赋值给变量`$MoreJson`\n\n之后我们使用`$MoreJsonName1`变量，赋值了变量`$MoreJson`中的成员`{'Name1'}`（也就是Name1中的 关于 这个词）\n\n如果`echo $MoreJsonName1`的话，结果就是：关于\n\n以此类推，就不多解释了\n\n\n\n## 在typecho中？\n\n先在functions.php中写一个选项\n\n```php\n    $MoreJSON = new Typecho_Widget_Helper_Form_Element_Textarea(\n    'MoreJSON',\n    NULL,\n    _t(''),\n    _t('了解更多模块设置'),\n    _t('此处填写Json，请看使用文档再进行填写')\n    );\n    $form->addInput($MoreJSON);\n```\n\n之后，直接转存到一个变量中\n\n```php\n/*\n * 解析MoreJSON信息\n * Author: Wibus\n * Used In Theme: Mix\n * 相关变量：$MoreJsonName $MoreJsonLink $MoreJsonMore\n * Date：2020.12.13\n */\n \n//$morejson = $this->options->MoreJSON; //获取设置选项\n$MoreJson = json_decode($this->options->MoreJSON); //对json转存为数组\n$MoreJsonName1 = $MoreJson->{'Name1'};\n$MoreJsonLink1 = $MoreJson->{'Link1'};\n$MoreJsonMore1 = $MoreJson->{'More1'};\n\n$MoreJsonName2 = $MoreJson->{'Name2'};\n$MoreJsonLink2 = $MoreJson->{'Link2'};\n$MoreJsonMore2 = $MoreJson->{'More2'};\n\n$MoreJsonName3 = $MoreJson->{'Name3'};\n$MoreJsonLink3 = $MoreJson->{'Link3'};\n$MoreJsonMore3 = $MoreJson->{'More3'};\n\n$MoreJsonName4 = $MoreJson->{'Name4'};\n$MoreJsonLink4 = $MoreJson->{'Link4'};\n$MoreJsonMore4 = $MoreJson->{'More4'};\n\n```"},{"title":"九上《道德与法治》","slug":"grade-9-first-volume-Law","created":"2020-12-13T12:57:59.029Z","modified":"2020-12-13T13:16:43.215Z","content":"\n\n## 第一课\t踏上强国之路\n\n本课共有*6个问题*需要背诵\n\n### 1. 改革开放的作用（改革开放怎样促进我国的发展）\n\n（1）我国逐步确立了公有制为主体、多种所有自经济共同发展，按劳分配为主体、多种分配制度并存，社会主义市场经济体制等社会主义`基本经济制度`。(基本经济制度)\n\n（2）改革开放使广大人民群众参与社会劳动、创造社会财富的`积极性和主动性`空前高涨。尊重劳动、尊重知识、尊重人才、尊重创造已成为社会共识。（四个尊重）\n\n（3）改革开放极大激发广大人民群众的创造性，极大解放和发展社会生产力，极大增强社会发展活力，实现了中国人民从站起来到富起来，强起来的伟大飞跃。（三个伟大）\n\n### 2. 改革开放的成果（中国腾飞的表现）\n\n（1）中国人民坚持改革开放，**极大地解放和发展了社会生产力**。在中国共产党的领导下，中国人民创造了人类发展史上的伟大奇迹，充分显示了**中国力量**。（综合国力方面）\n\n（2）中国**人民**通过改革开放过上了**幸福生活**。（人民生活方面）\n\n（3）改革开放不仅深刻**改变了中国**，也**深刻影响着世界**。中国已经成为世界经济增长的主要**稳定器和动力源**，成为**影响世界的重要力量**（国际影响力方面）\n\n### 3. 中国的腾飞\n\n中国的腾飞证明：改革开放是决定当代中国命运的`关键抉择`\n\n### 4. Why 全面深化改革（只有进行时，没有完成时）\n\n（1）进入新时代，我国`主要矛盾`转化成**人民日益增长的美好生活需要和不平衡不充分发展**之间的矛盾（主要矛盾）\n\n（2）我国经济已由**高速增长**阶段转向`高质量发展`阶段，需要**转变发展方式，优化经济结构，转换增长动力**，建设现代化经济体系（高质量发展）\n\n（3）我国经济发展还面临*区域发展不平衡，城镇化水平不高，城乡发展不平衡不协调*等现实挑战（三大挑战）\n\n（4）改革开放是当代中国最鲜明的特色（鲜明特色）\n\n### 5. Why 要坚持共享发展成果\n\n（1）**衡量一个社会的文明程度**，不仅要看经济的发展，而且要看发展成果是否惠及全体人民，人民的合法权益是否得到切实保障。\n\n（2）人民对美好生活的向往就是**党的奋斗目标**。\n\n（3）发展的**根本目的**就是增进民生福祉。\n\n### 6. How 让人民共享发展成果\n\n（1）党和政府坚持`以人民为中心`的发展思想，强调人人参与，人人尽力，人人享有，让人民群众共享发展成果（以人民为中心）\n\n（2）抓住人民*最关心最直接最现实*的利益问题，不断满足人民日益增长的美好生活需要，使人民的*获得感，幸福感，安全感*更加充实、更有保障、更可持续（解决民生）\n\n（3）坚持和完善**社会主义制度**"},{"title":"关于Mix主题的开发","slug":"how-to-develop-mix-typecho","created":"2020-12-13T09:31:26.646Z","modified":"2020-12-27T10:30:33.898Z","content":"\n\n> Mix 是一款Typecho主题，根据Mix-Space进行仿写，目前基本可以投入使用！\n\n使用文档在此：https://iucky.cn/posts/play/typecho-theme-Mix\n\n---\n\n想要内测的大佬请加群哇，以及时报告错误🙅：\n\n点击链接加入群聊【Theme-Mix】：https://jq.qq.com/?_wv=1027&k=nIdoRbMY\n\n**也是万分感谢您能来内测本主题！暂时先不开源**\n\n## TODO\n\n> **{xxx}** 指实现功能使用的方法\n\n* [x] 首页分部件编写 **{index.php}**\n* [x] 自动识别h1, h2, h3...\n* [x] 首页显示随机缩略图 **{libs.php}**\n* [x] 模板备份设置功能 **{functions.php}**\n* [x] 文章样式选择 **{文章 / 日记}**\n* [X] 完善内页\n* [X] Pjax 无刷新体验 (Require .js) **{footer.php}**\n* [X] functions.php 更新检测（不想用JavaScript控制了）\n* [X] 部件「了解更多」使用json进行设置\n* [X] 短代码功能 **{libs.php}**\n* [ ] 评论区功能\n* [ ] 多种配件样式选择\n* [ ] 日记可添加心情，天气等配件\n* [ ] 详细的时间线\n* [ ] 首页、内页的朋友们\n* [ ] 动态载入效果 (Require .js)\n* [ ] 基本的代码高亮 (Require .js)\n* [ ] 部件「了解更多」优化json解析，取消固定显示限制\n* [ ] 修改Typecho后台，变成Mix-Space后端样式（以插件形式）\n* [ ] 项目、一言功能\n* [ ] 夜晚模式\n* [ ] Aplayer播放器功能\n\n## 开发日志\n\n- Version: `V1.0.0`\n\n  Date: 2020-12-12\n\n  Update Log: \n\n  1. 选择首页显示部件\n  2. 自定义CSS，自定义 Javascript\n  3. 自定义 头部、底部HTML输出\n  4. 自定义底部左、右侧文字信息\n\n- Version: `V1.1.0`\n\n  Date: 2020-12-13\n\n  Update Log:\n\n  1. 新增文章样式选择「文章 / 日记」\n  2. 外观设置加入备份设置功能\n  3. 解决加载woff报错问题，修复原有评论区样式（评论区尚未上线）\n  4. 添加自定义选项：首页显示部件，顶部图标跳转链接等\n  5. 将博文、日记输出改为输出最新的4篇\n  6. ~~部件「了解更多」使用json进行设置内容~~（出现问题）\n  \n- Version: `V1.2.0`\n\n  Date: 2020-12-19\n  \n  Update Log:\n  \n  1. 部件「了解更多」使用json进行设置内容\n  2. 增加了随机图片的链接数量\n  3. 修补Issue中提到的问题\n  4. 首页`最新博文`类的标题背景加入随机显示颜色功能\n  5. 增加文章显示更多功能，日记获取最新文章\n  6. 补充了页面，重写了libs.php\n  7. 主题开始支持更新检测\n  8. 加入全站Pjax！\n  \n    \n- Version: `V1.2.1`\n\n  Date: 2020-12-20\n  \n  1. 因Pjax引起的样式问题的修复\n  \n  \n- Version: `V1.2.2`\n\n  Date: 2020-12-27\n  \n  1. 新增了十几个代码框（ https://iucky.cn/posts/works/super-code-ui ）\n  2. 修复头部图标点击无法返回的问题\n  3. 添加了Pjax重载函数的设置\n  4. 在准备Pro版的研发\n  5. 修复了一个function的问题\n  6. *`[scode]`短代码功能*\n  \n  > 此版本开始需要授权，请找管理要授权码之后填写在外观设置里～\n\n\n## Known Issues\n\n\n* [X] libs.php 在某些博客上出现重复声明函数的错误 **(解决方法：请认真看使用文档进行配置哦)**\n* [X] 随机图片有机率重复显示 **(V1.2.0已修复，但还是有时候会出现问题)**\n* [X] 文章底部版权提示字体颜色不受控制 **(V1.2.0已修复)**\n* [X] 了解更多json配置后无效 **(V1.2.0已修复)**\n* [X] Pjax导致的样式错误 **(V1.2.1已修复)**\n* [X] 头部图标点击无法返回的问题 **(V1.2.2已修复)**\n\n\n## 开发的过程中使用的文章\n\nCSS 实现自适应： https://iucky.cn/posts/code/css-auto-device\n\nTypecho自定义字段： https://iucky.cn/posts/code/typecho-custom-fields\n\nPHP随机一句话：https://iucky.cn/posts/code/php-one-words\n\nPHP解析JSON：https://iucky.cn/posts/code/php-parsing-json\n\nTypecho调用某一分类下的文章：https://iucky.cn/posts/code/typecho-use-one-category\n\nSuper Code UI：https://iucky.cn/posts/works/super-code-ui\n\nTypecho实现短代码功能：https://iucky.cn/posts/play/typecho-shortcode"},{"title":"Mix 使用文档","slug":"typecho-theme-Mix","created":"2020-12-13T09:28:11.695Z","modified":"2020-12-27T07:28:00.030Z","content":"\n\n> Mix —— 空间混合体\n\n## 前期准备工作\n\n**⚠️注意，这个不是Mix-Space！部署Mix-Space的请前往 https://iucky.cn/mix-space-start**\n\n\n想要内测的大佬请加群哇，以及时报告错误🙅：\n\n点击链接加入群聊【Theme-Mix】：https://jq.qq.com/?_wv=1027&k=nIdoRbMY\n\n> 万分感谢您能来内测本主题！\n\n\n下载主题文件并上传至站点themes目录，解压并修改文件夹名为`Mix`\n\n站点后台启动主题即可食用～\n\n## 主题必要设置\n\n你只能拥有两个分类，一个是输出文章的，一个是输出日记的（当然不使用日记可以不新建）我们使用标签来作为分类显示😂\n\n输出`文章`的分类名可以自己定义，但是分类缩略名请写`article`\n\n输出`日记`的分类名可以自己定义，但是分类缩略名请写`dairy`\n\n下面是一些说明图片\n\n![edit](https://gitee.com/wibus/blog-assets-goo/raw/master/asset-pic/edit.png)\n![cate](https://gitee.com/wibus/blog-assets-goo/raw/master/asset-pic/cate.png)\n\n### 了解更多Json\n\nName是指名字，Link是指跳转链接，More是指描述\n\n至于后面的数字就是第几个（必须要4个，目前策略不够完善，以后修正）\n\n例子：\n\n```json\n{\n  \"Name1\": \"关于\", \n  \"Link1\": \"https://iucky.cn/about\",\n  \"More1\": \"关于我的一切\",\n  \n  \"Name2\": \"留言\", \n  \"Link2\": \"https://iucky.cn/message\",\n  \"More2\": \"留言刷刷走起来\", \n  \n  \"Name3\": \"Mix-space\", \n  \"Link3\": \"https://iucky.cn/mix-space\", \n  \"More3\": \"Mix-Space使用文档\",\n  \n  \"Name4\": \"订阅\", \n  \"Link4\": \"https://iucky.cn/feed\",\n  \"More4\": \"来份订阅很不错！\"\n}\n```\n\n### 更多文章页面\n\n1. 请先去新增独立页面，自定义模板选择`首页显示更多`，路径和页面名字自己填写，之后设置为隐藏，建议填写好记一点的，之后记住他，保存\n\n2. 去到外观设置中，找到 `显示更多文章链接` 选项，下面输入你刚刚新建的页面地址，保存设置即可！\n\n### 短代码功能\n\nMix 短代码介绍：https://iucky.cn/posts/things/mix-shortcode\n\n## 开发日志\n\nhttps://iucky.cn/posts/things/how-to-develop-mix-typecho"},{"title":"CSS 实现自适应","slug":"css-auto-device","created":"2020-12-13T06:41:07.881Z","modified":"2020-12-13T06:43:08.166Z","content":"\n\n## 前言\n\n最近开始折腾另一个项目（暂时不透露哈哈哈哈）需要用到自适应布局，于是就探究了一下～\n\n## 实现方法\n\n首先得引入CSS3 @media 媒体查询器\n\n\nmedia的使用和规则：\n\n　　①被链接文档将显示在什么设备上。\n\n　　②用于为不同的媒介类型规定不同的样式。\n\n\n\n语法：\n\n```css\n\n @media 设备名 only （选取条件） not （选取条件） and（设备选取条件），设备二{sRules}\n\n```\n\n## 实例：\n\n```css\n\n /* 这是匹配横屏的状态，横屏时的css代码 */\n\n@media all and (orientation :landscape){}　　　\n\n/* 这是匹配竖屏的状态，竖屏时的css代码 */　　　　\n\n@media all and (orientation :portrait){}\n\n@media X and (min-width:200px){}\n\n/*X为媒体类型--->比如print/screen/TV等等*/\n\n/* 宽度大于600px小于960之间时，隐藏footer结构 */\n\n@media all and (min-height:640px) and (max-height:960px){\n\n  　　　footer{display:none;}\n\n} \n\n```\n\n> 在实际应用的时候，首先得在HTML的头文件 `<head>`里上加入以下代码：\n\n```html\n\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n\n```\n## 前言\n\n最近开始折腾另一个项目（暂时不透露哈哈哈哈）需要用到自适应布局，于是就探究了一下～\n\n## 实现方法\n\n首先得引入CSS3 @media 媒体查询器\n[scode type=\"blue\"]\nmedia的使用和规则：\n\n　　①被链接文档将显示在什么设备上。\n\n　　②用于为不同的媒介类型规定不同的样式。\n[/scode]\n\n语法：\n\n```css\n @media 设备名 only （选取条件） not （选取条件） and（设备选取条件），设备二{sRules}\n```\n\n## 实例：\n\n```css\n /* 这是匹配横屏的状态，横屏时的css代码 */\n@media all and (orientation :landscape){}　　　\n/* 这是匹配竖屏的状态，竖屏时的css代码 */　　　　\n@media all and (orientation :portrait){}\n@media X and (min-width:200px){}\n/*X为媒体类型--->比如print/screen/TV等等*/\n/* 宽度大于600px小于960之间时，隐藏footer结构 */\n@media all and (min-height:640px) and (max-height:960px){\n  　　　footer{display:none;}\n} \n```\n\n> 在实际应用的时候，首先得在HTML的头文件 `<head>`里上加入以下代码：\n\n```html\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n```\n\n### 解释：　　\n\n**width = device-width**：宽度等于当前设备的宽度\n\n**initial-scale**：初始的缩放比例（默认设置为1.0）\n\n**minimum-scale**：允许用户缩放到的最小比例（默认设置为1.0）\n\n**maximum-scale**：允许用户缩放到的最大比例（默认设置为1.0）\n\n**user-scalable**：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面）\n\n---\n\n**因为media的类型很多，这里就发菜鸟教程的对应链接了：http://www.runoob.com/cssref/css3-pr-mediaquery.html**\n\n下面是media类型的screen（用于电脑屏幕，平板电脑，智能手机等）：**\n\n## css自适应屏幕大小\n\n```css\n@media screen and (min-width: 320px) and (max-width: 1156px){\n\n               .site-bg-dl {\n               position: fixed;\n               height: 100%;\n               width: 100%;\n               z-index: 0;\n               background-image: url(bjxzfwzx/images/bj1.png);\n               background-size: cover;\n               background-repeat: no-repeat;\n               background-attachment: fixed;\n               background-size:100% 100%;\n               -moz-background-size:100% 100%;\n             }\n }\n```\n\n### 解释：\n\n告诉浏览器当屏幕大于320px，并小于1156px下执行此代码\n\n## 定制不同屏幕的显示样式：\n\n```css\n /* 大屏幕 ：大于等于1200px*/\n @media (min-width: 1200px) { \n           /*Your Code*/\n }\n\n /*默认*/\n @media (min-width: 980px){\n           /*Your Code*/\n}\n\n /* 平板电脑和小屏电脑之间的分辨率 */\n @media (min-width: 768px) and (max-width: 979px) { \n           /*Your Code*/\n }\n\n /* 横向放置的手机和竖向放置的平板之间的分辨率 */\n @media (max-width: 767px) { \n           /*Your Code*/\n}\n\n /* 横向放置的手机及分辨率更小的设备 */\n @media (max-width: 480px) {\n           /*Your Code*/\n}\n```\n\n### 解释：　　\n\n**width = device-width**：宽度等于当前设备的宽度\n\n**initial-scale**：初始的缩放比例（默认设置为1.0）\n\n**minimum-scale**：允许用户缩放到的最小比例（默认设置为1.0）\n\n**maximum-scale**：允许用户缩放到的最大比例（默认设置为1.0）\n\n**user-scalable**：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面）\n\n---\n\n**因为media的类型很多，这里就发菜鸟教程的对应链接了：http://www.runoob.com/cssref/css3-pr-mediaquery.html**\n\n下面是media类型的screen（用于电脑屏幕，平板电脑，智能手机等）：**\n\n## css自适应屏幕大小\n\n```css\n\n@media screen and (min-width: 320px) and (max-width: 1156px){\n\n               .site-bg-dl {\n\n               position: fixed;\n\n               height: 100%;\n\n               width: 100%;\n\n               z-index: 0;\n\n               background-image: url(bjxzfwzx/images/bj1.png);\n\n               background-size: cover;\n\n               background-repeat: no-repeat;\n\n               background-attachment: fixed;\n\n               background-size:100% 100%;\n\n               -moz-background-size:100% 100%;\n\n             }\n\n }\n\n```\n\n### 解释：\n\n告诉浏览器当屏幕大于320px，并小于1156px下执行此代码\n\n## 定制不同屏幕的显示样式：\n\n```css\n\n /* 大屏幕 ：大于等于1200px*/\n\n @media (min-width: 1200px) { \n\n           /*Your Code*/\n\n }\n\n /*默认*/\n\n @media (min-width: 980px){\n\n           /*Your Code*/\n\n}\n\n /* 平板电脑和小屏电脑之间的分辨率 */\n\n @media (min-width: 768px) and (max-width: 979px) { \n\n           /*Your Code*/\n\n }\n\n /* 横向放置的手机和竖向放置的平板之间的分辨率 */\n\n @media (max-width: 767px) { \n\n           /*Your Code*/\n\n}\n\n /* 横向放置的手机及分辨率更小的设备 */\n\n @media (max-width: 480px) {\n\n           /*Your Code*/\n\n}\n\n```"},{"title":"Typecho自定义字段","slug":"typecho-custom-fields","created":"2020-12-12T15:18:28.003Z","modified":"2020-12-12T15:18:27.987Z","content":"\n\n这不今天做主题嘛，就遇到了一些需要使用自定义字段的功能，找了下网上，之后自己整理了下\n\n## 对自定义字段进行判断操作\n\n*PostChoice* 是自定义字段的名字，我使用在：*post.php / page.php* 中\n\n先使用`<?php $PostChoice = $this->fields->PostChoice;?>`赋个值再做操作\n\n之后使用`<?php if ($PostChoice == 0): ?>`，`<?php else: ?>`，`<?php endif; ?>`，做出判断\n\n在中间写入我想要的HTML代码\n\n> 一般我都会用`<?php ?>`这样子来做PHP判断再输出其他代码\n\n```php\n<?php $PostChoice = $this->fields->PostChoice;?>\n\n<?php if ($PostChoice == 0): ?>\n\n<main class=\"is-article\">\n<?php $this->need('component/headnav.php'); ?>\n<?php $this->need('component/article_post.php'); ?>\n</main>\n\n<?php elseif ($PostChoice == 1): ?>\n\n<main class=\"is-article is-note post-content paul-note\">\n<?php $this->need('component/headnav.php'); ?>\n<?php $this->need('component/dairy_post.php'); ?>\n</main>\n\n<?php else: ?>\n\n<main class=\"is-article\">\n<?php $this->need('component/headnav.php'); ?>\n<?php $this->need('component/article_post.php'); ?>\n</main>\n\n<?php endif; ?>\n```\n\n## 编写文章时设置\n\n这样子就能在编写文章的时候自定义字段中显示设置，可以进行选择而不需要去点击**新增->写字段名字->写字段值**\n\n```php\n/*\n * 编写文章设置\n * themeFields(Typecho_Widget_Helper_Layout $layout){}控制\n */\nfunction themeFields(Typecho_Widget_Helper_Layout $layout){\n\n    $PostChoice = new Typecho_Widget_Helper_Form_Element_Select('PostChoice', array(\n        '0'=>'文章样式',\n        '1'=> '日记样式'\n    ),'0', _t('当前文章页面样式类型'), '<strong style=\"color:red;\">该设置仅对该篇文章有效</strong></br>默认选项是「文章」样式</br> 选择「日记」当前文章页面样式将会改为日记样式</br>不建议文章使用日记样式，日记使用文章样式');\n    $layout->addItem($PostChoice);\n\n}\n```"},{"title":"网站背景添加海浪背景","slug":"css-wave-background","created":"2020-12-12T03:34:55.499Z","modified":"2020-12-27T11:23:47.013Z","content":"\n\n> https://cmsboy.cn/archives/243.html 是抄袭了本站的文章的，请大家认识一下这位博主\n> 具体可以看这里：https://iucky.cn/notes/3\n\n用CSS和HTML实现\n\nCSS怎么放就不需要说了吧？\n\n```css\n/* 海浪背景CSS部分 */\n#wavesDIV{position: fixed;bottom: 0;width: 100%;display:block;height:20vh;background-color:rgb(125,165,191);animation: move-out 2s cubic-bezier(0,.98,.97,1) forwards;}\n.waves { position:relative; width: 100%; height:15vh; margin-top:-15vh; min-height:100px; max-height:150px; }\n.parallax > use { animation: move-forever 25s cubic-bezier(.55, .5, .45, .5) infinite; } \n.parallax > use:nth-child(1) { animation-delay: -2s; animation-duration: 7s; } \n.parallax > use:nth-child(2) { animation-delay: -3s; animation-duration: 10s; } \n.parallax > use:nth-child(3) { animation-delay: -4s; animation-duration: 13s; } \n.parallax > use:nth-child(4) { animation-delay: -5s; animation-duration: 20s; } \n@keyframes move-forever { 0% { transform: translate3d(-90px, 0, 0); } 100% { transform: translate3d(85px, 0, 0); } }\n@keyframes move-out { 0% { transform: translateY(400%); } 100% { transform: translateY(0%); } }\n```\n\nHTML加入到网站随意一个地方，我是加到body里的，因为有些时候放在下面会被其他元素覆盖掉\n\n\n```html\n<div id=\"wavesDIV\" style=\"display: block;\">\n        <svg class=\"waves\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 24 150 28\" preserveAspectRatio=\"none\" shape-rendering=\"auto\">\n            <defs>\n                <path id=\"gentle-wave\" d=\"M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z\"></path>\n            </defs>\n            <g class=\"parallax\">\n                <use xlink:href=\"#gentle-wave\" x=\"48\" y=\"-2\" fill=\"rgba(125,165,191,0.3)\"></use>\n                <use xlink:href=\"#gentle-wave\" x=\"48\" y=\"3\" fill=\"rgba(125,165,191,0.5)\"></use>\n                <use xlink:href=\"#gentle-wave\" x=\"48\" y=\"5\" fill=\"rgba(125,165,191,0.7)\"></use>\n                <use xlink:href=\"#gentle-wave\" x=\"48\" y=\"12\" fill=\"rgba(125,165,191,1)\"></use>\n            </g>\n        </svg>\n    </div>\n```"},{"title":"PHP随机一句话","slug":"php-one-words","created":"2020-12-12T00:47:28.170Z","modified":"2020-12-12T00:47:28.161Z","content":"\n\n效果有点类似 一言的效果吧。不过一言是API，我完全不懂==，而且还有分类什么的，这个只是简单点的。\n\n记录并分析一下代码：\n```php\nfunction random_str () { \n$poems=\"从善如登，从恶如崩。 \n已知花意，未见其花，已见其花，未闻花名 \n如果能不长大就好了啊 可是时光在身后挡住退路。 \n或许前路永夜，即便如此我也要前进，因为星光即使微弱也会为我照亮前路 \n你驻足于春色中，于那独一无二的春色之中\n喜欢的人喜欢别人不是很正常吗。\n生活是不公平的；要去适应它。——比尔盖茨\n人生就是一列开往坟墓的列车，路途上会有很多站，很难有人可以自始至终陪着走完。当陪你的人要下车时，即使不舍也该心存感激，然后挥手道别。\"; \n$poems=explode(\"\\n\",$poems); \nreturn $poems[rand(0,count($poems)-1)]; \n} \nfunction says(){ \n$says=random_str(); \necho $says; \n} \n```\n*explode(separator,string,limit)*\n作用：把字符串以“separator”格式打散成数组，存储在“string”里面。limit是可选参数。\n\n*rand(0,count($poems)-1)*\n在0，和数组的长度大小 里面随机取一个。和C语言有点类似。\n\n最后在需要的地方，写上这个代码就行：\n```php\n<?php says(); ?>\n```\n记录以备用之。"},{"title":"用代码美化文字Ads","slug":"ads-beautiful-css","created":"2020-12-11T22:22:03.103Z","modified":"2020-12-11T22:28:19.137Z","content":"\n\n没办法，有一些广告位实在是太丑了，于是就自己搞了一个不错的广告位的样式代码，个人觉得还不错的哈哈哈哈\n\n## HTML\n\nHTML我们只需要用一个class=\"ads\"的标签包裹住里面所有的内容就好了，自行发挥\n\n\n```html\n<a class=\"ads\" target=\"_blank\">\n  <h4 style=\"color: white;\">这里是大字体\n  </h4>\n  <h5 style=\"color: white;\">\n    这里是小字</h5>\n  <span class=\"ads-btn ads-btn-outline\">\n    这里是按键\n  </span>\n</a>\n```\n\n## CSS\n\n```css\n/* Ads美化 */\n.ads {\n\tdisplay: block;\n\tpadding: 40px 15px;\n\ttext-align: center;\n\tcolor: #fff!important;\n\tbackground: #ff5719;\n\tbackground-image: -webkit-linear-gradient(135deg,#bbafe7,#5368d9);\n\tbackground-image: linear-gradient(135deg,#bbafe7,#5368d9);\n}\n\n.ads h4 {\n\tmargin: 0;\n\tfont-size: 22px;\n\tfont-weight: bold\n}\n\n.ads h5 {\n\tmargin: 10px 0 0;\n\tfont-size: 14px;\n\tfont-weight: bold\n}\n\n.ads.ads-btn {\n\tmargin-top: 20px;\n\tfont-weight: bold\n}\n\n.ads.ads-btn:hover {\n\tcolor: #ff5719\n}\n\n.ads-btn {\n\tdisplay: inline-block;\n\tfont-weight: normal;\n\tmargin-top: 10px;\n\tcolor: #666;\n\ttext-align: center;\n\tvertical-align: top;\n\tuser-select: none;\n\tborder: 0;\n\tpadding: 0 36px;\n\tline-height: 38px;\n\tfont-size: 14px;\n\tborder-radius: 10px;\n\toutline: 0;\n\t-webkit-transition: all .3s ease-in-out;\n\t-moz-transition: all .3s ease-in-out;\n\ttransition: all .3s ease-in-out\n}\n\n.ads-btn:hover,.btn:focus,.btn.focus {\n\toutline: 0;\n\ttext-decoration: none\n}\n\n.ads-btn:active,.btn.active {\n\toutline: 0;\n\tbox-shadow: inset 0 3px 5px rgba(0,0,0,0.125)\n}\n\n.ads-btn-outline {\n\tline-height: 36px;\n\tcolor: #fff;\n\tbackground-color: transparent;\n\tborder: 1px solid#fff\n}\n\n.ads-btn-outline:hover,.btn-outline:focus,.btn-outline.focus {\n\tcolor: #343a3c;\n\tbackground-color: #fff\n}\n```"},{"title":"初三我们该如何学习","slug":"how-to-learn-grade9","created":"2020-12-10T13:53:25.927Z","modified":"2020-12-11T22:28:46.687Z","content":"\n\n整体总结了下，尽量精简啦\n\n## 语文\n\n1. **背书！！！**\n\n 其实这个是文科无法避免的一个事实哈哈哈₍₍ (̨̡ ‾᷄ᗣ‾᷅ )̧̢ ₎₎\n \n 我们需要利用好零碎时间来背书，比如说放学回家就可以背背\n \n2. **平时认真作业阅读，跟随老师的步伐**\n\n 上课是非常重要的，我们虽然语文书上的阅读考试并不会考\n \n 但是我们上课是要去学习如何去分析文段的，之后通过学习来在考试的时候使用\n \n3. **写作时利用好素材积累，可以尝试将一件事运用在不同的作文题目当中**\n\n 日常可以多多积累素材，可以搞一个素材本\n \n4. **丰富的阅读量**\n5. **注意书写**\n\n## 数学\n\n需要**打好基础，明确考点**\n\n1. **做思维导图**\n2. **不要小看数学书**\n\n有些人会去选择去*刷题*，那么在这里也说说怎么样去有效刷题\n\n### 如何正确刷题？\n\n我们刷题的根本目的其实是 发现问题，解决问题\n\n1. 有选择地刷题，刷错题，新体型，不会的题目\n2. 总结做题过程遇到的困惑，哪些点自己不懂，答案的思路是怎样的？找思路，模仿思想\n\n---\n\n咕咕咕一阵子先😂"},{"title":"C语言实现附庸套娃","slug":"c-fuyong-doll","created":"2020-12-09T14:37:33.422Z","modified":"2020-12-09T14:54:58.792Z","content":"\n\n## 描述\n\n其实从历史课的时候学到那个分封制：“我的附庸的附庸不是我的附庸”的时候就已经想做这个了，谁知道拖了1个多月，我才开始做😂\n\n其实这次要实现的很简单，总体主要要写的就是一个for循环，当然可以写while或者do-while，我这边选择for吧，毕竟比较常见的\n\n## 开始编写\n\n首先，我们肯定要引入头文件的\n\n```c\n\n#include <stdio.h>\n\n```\n\n基本的main写一下\n\n```c\n\nint main(void){\n\n  return 0;\n\n}\n\n```\n\n哦对，这里有关于一个int main()后面这个括号的一个小学问，在这里先不展开讲～\n\n总之就推荐使用**int main(void)**，至于为什么，之后我再写\n\n接着我们先定义一个变量**a**，用于获取附庸的数量（我下文就把它说成循环次数了，具体为什么看分析），scanf获取值，用prinf输出友好的输入提示\n\n```c\n\nint main(void) {\n    printf(\"input: \");\n    int a;\n    scanf(\"%d\", &a);\n  return 0;\n}\n\n```\n\n接着我们就开始编写主要内容了\n\n## 主要内容分析\n\n其实也没有什么了，我们先把这一句拆分开来：我的附庸的附庸不是我的附庸\n\n一般常人理解是：我的附庸的附庸，不是我的附庸。虽然这样子理解是正确的\n\n但是我们编写程序的时候，还需要做到一个重复吧？\n\n举个例子：我的附庸的附庸的附庸不是我的附庸的附庸不是我的附庸\n\n> 在此程序生成的，不自己写了😂\n\n我们可以看到有一段文字是一直在重复的，他就是**的附庸**\n\n所以我们需要把这句话拆分为：我 的附庸 的附庸 不是我 的附庸 的附庸\n\n那接下来，就好写了\n\n## 主要内容编写\n\n首先我们写出最基本的句子：我 的附庸 不是我 的附庸，之后再做for循环\n\n```c\n\n    printf(\"我\");\n    printf(\"的附庸\");\n    printf(\"不是我\");\n    printf(\"的附庸\");\n\n```\n\n还记得我们之前有过一个变量a吗？a用于获取循环的次数，那么我们使用for进行循环\n\n首先是第一个**的附庸**\n\n```c\n\n    printf(\"我\");\n    for(int b = a; b == 0, b--;) {\n        printf(\"的附庸\");\n    }\n\n```\n\n我们重新定义了一个int变量：b，因为我们要让a这个值不能发生改变，后面会继续用到a这个变量\n\n说一下这个for吧，`int b = a; b == 0, b--;`，定义变量b类型为int，值为当前变量a的值；在当b==0的时候退出for循环，每次循环过后进行b--;\n\n接着就是下面的不是我 的附庸了\n\n由于在a > 3后，不是我也要重复，所以我们使用for嵌套，就像是这样子\n\n```c\n    a--;\n\t\tint e = a;\n    for (int d = e--; d == 0, d--;) {\n        printf(\"不是我\");\n        for(int c = a--; c == 0, c--;) {\n        printf(\"的附庸\");\n        }\n    }\n\n```\n\n当中我们定义了一个int变量e，数值为a--之后的数，for循环我就不解释了，大家自己看吧\n\n## 效果展示\n\n```bash\n\ninput: 5\n\n我的附庸的附庸的附庸的附庸的附庸不是我的附庸的附庸的附庸的附庸不是我的附庸的附庸的附庸不是我的附庸的附庸不是我的附庸\n\n```\n\n那我们把上述代码归纳总结，就是这样子的\n\n```c\n\n//\n//  main.c\n//  My_Dependency\n//\n//  Created by wibus on 2020/11/28.\n//\n#include <stdio.h>\n\nint main(void) {\n    printf(\"input: \");\n    int a;\n    scanf(\"%d\", &a);\n    printf(\"我\");\n    for(int b = a; b == 0, b--;) {\n      printf(\"的附庸\");\n    }\n    a--;\n    int e = a;\n    for (int d = e--; d == 0, d--;) {\n        printf(\"不是我\");\n        for(int c = a--; c == 0, c--;) {\n            printf(\"的附庸\");\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n```\n\n运行项目可以在网上搜索C语言在线开发环境运行的\n\n## 小伙伴写的\n\n同样有个小伙伴也写了个噢～\n\n文章标题: PHP附庸套娃来啦(bushi)\n\n文章作者: 神奇のDz\n\n文章链接:https://www.ecy.pink/Code/phpFyCode.html"},{"title":"Typecho自定义评论列表区域","slug":"typecho-own-comment","created":"2020-12-09T14:36:45.966Z","modified":"2020-12-12T22:50:35.196Z","content":"\n\n## 自定义单条评论的HTML代码\n\n在自定义评论前，先设计好单条评论的 HTML 代码结构，如：\n\n```html\n<li class=\"comment-body comment-parent comment-odd\">\n    <div>\n        <div class=\"comment-author\">\n            <img class=\"avatar\" src=\"avatar.png\" alt=\"\" width=\"40\" height=\"40\">\n            <cite class=\"fn\"><a href=\"评论者主页\">评论者名字</a></cite>\n        </div>\n        <div class=\"comment-meta\">\n            <a href=\"评论地址\">评论时间</a>\n            <span class=\"comment-reply\">回复按钮</span>\n        </div>\n        <p>评论内容</p>\n    </div><!-- 单条信息内容 -->\n    <div class=\"comment-children\">\n        <!-- 评论相关 -->\n    </div>\n</li>\n```\n\n## 使用自定义评论函数\n\n打开 comments.php 文件，需要在它的顶部，插入以下函数代码：\n\n```php\n<?php function threadedComments($comments, $options) {\n    $commentClass = '';\n    if ($comments->authorId) {\n        if ($comments->authorId == $comments->ownerId) {\n            $commentClass .= ' comment-by-author';  //如果是文章作者的评论添加 .comment-by-author 样式\n        } else {\n            $commentClass .= ' comment-by-user';  //如果是评论作者的添加 .comment-by-user 样式\n        }\n    } \n    $commentLevelClass = $comments->_levels > 0 ? ' comment-child' : ' comment-parent';  //评论层数大于0为子级，否则是父级\n?>\n/* 自定义评论的代码结构 */\n<?php } ?>\n```\n\n其次，将刚才自定义好的单条评论的 HTML 代码，放在上面代码里注释的地方，如下：\n\n```php\n<?php function threadedComments($comments, $options) {\n    $commentClass = '';\n    if ($comments->authorId) {\n        if ($comments->authorId == $comments->ownerId) {\n            $commentClass .= ' comment-by-author';  //如果是文章作者的评论添加 .comment-by-author 样式\n        } else {\n            $commentClass .= ' comment-by-user';  //如果是评论作者的添加 .comment-by-user 样式\n        }\n    } \n    $commentLevelClass = $comments->_levels > 0 ? ' comment-child' : ' comment-parent';  //评论层数大于0为子级，否则是父级\n?>\n \n/* 自定义评论的代码结构 */\n<li class=\"comment-body comment-parent comment-odd\">\n    <div>\n        <div class=\"comment-author\">\n            <img class=\"avatar\" src=\"avatar.png\" alt=\"\" width=\"40\" height=\"40\">\n            <cite class=\"fn\"><a href=\"评论者主页\">评论者名字</a></cite>\n        </div>\n        <div class=\"comment-meta\">\n            <a href=\"评论地址\">评论时间</a>\n            <span class=\"comment-reply\">回复按钮</span>\n        </div>\n        <p>评论内容</p>\n    </div><!-- 单条信息内容 -->\n    <div class=\"comment-children\">\n        <!-- 评论相关 -->\n    </div>\n</li>\n<?php } ?>\n```\n\n## 变量替换HTML中相关属性\n\n把 HTML 里相关的属性，替换成 typecho 系统中的评论变量，变量的列表可以参考下面。下面的例子，是替换评论的 id：\n\n```html\n<!-- 替换前 -->\n<li class=\"comment-body comment-parent comment-odd\">\n```\n\n```php\n/* 替换后 */\n<li id=\"li-<?php $comments->theId(); ?>\" class=\"comment-body<?php \nif ($comments->_levels > 0) {\n    echo ' comment-child';\n    $comments->levelsAlt(' comment-level-odd', ' comment-level-even');\n} else {\n    echo ' comment-parent';\n}\n$comments->alt(' comment-odd', ' comment-even');\necho $commentClass; \n?>\">\n```\n\n替换ID需要判断判断当前评论是父级评论还是子级评论，且判断评论 ID 的奇偶数\n\n## 子评论\n\n替换前：\n\n```html\n<div class=\"comment-children\">\n    <!--评论相关 -->\n</div>\n```\n\n替换后后如下：\n\n```html\n<?php if ($comments->children) { ?> //是否子评论\n<div class=\"comment-children\">\n    <?php $comments->threadedComments($options); ?> //嵌套评论所有内容\n</div>\n<?php } ?> //判断结束\n```\n\n## 五、相关变量及说明\n\n| 变量                                    | 说明                                     |\n| --------------------------------------- | ---------------------------------------- |\n| <?php $comments->gravatar('40', ''); ?> | 头像，有两个参数，大小、默认头像         |\n| <?php $comments->author(); ?>           | 评论作者                                 |\n| <?php $comments->permalink(); ?>        | 当前评论的连接地址                       |\n| <?php $comments->date('Y-m-d H:i'); ?>  | 评论时间，可在括号里设置格式             |\n| <?php $comments->reply(); ?>            | 回复按钮，可在括号里自定义评论按钮的文字 |\n| <?php $comments->content(); ?>          | 评论内容                                 |\n\n\n\n## 六、最终得到的代码\n\n当把上面所有变量都替换完成之后，最终得到的代码如下：\n\n```PHP\n<?php function threadedComments($comments, $options) {\n    $commentClass = '';\n    if ($comments->authorId) {\n        if ($comments->authorId == $comments->ownerId) {\n            $commentClass .= ' comment-by-author';\n        } else {\n            $commentClass .= ' comment-by-user';\n        }\n    }\n \n    $commentLevelClass = $comments->levels > 0 ? ' comment-child' : ' comment-parent';\n?>\n \n<li id=\"li-<?php $comments->theId(); ?>\" class=\"comment-body<?php \nif ($comments->levels > 0) {\n    echo ' comment-child';\n    $comments->levelsAlt(' comment-level-odd', ' comment-level-even');\n} else {\n    echo ' comment-parent';\n}\n$comments->alt(' comment-odd', ' comment-even');\necho $commentClass;\n?>\">\n    <div id=\"<?php $comments->theId(); ?>\">\n        <div class=\"comment-author\">\n            <?php $comments->gravatar('40', ''); ?>\n            <cite class=\"fn\"><?php $comments->author(); ?></cite>\n        </div>\n        <div class=\"comment-meta\">\n            <a href=\"<?php $comments->permalink(); ?>\"><?php $comments->date('Y-m-d H:i'); ?></a>\n            <span class=\"comment-reply\"><?php $comments->reply(); ?></span>\n        </div>\n        <?php $comments->content(); ?>\n    </div>\n<?php if ($comments->children) { ?>\n    <div class=\"comment-children\">\n        <?php $comments->threadedComments($options); ?>\n    </div>\n<?php } ?>\n</li>\n<?php } ?>\n```\n\n注意：上面的自定义评论代码输出的，就是本来评论页里的下面这段代码，所以你就不用对这段代码做任何更改了。\n\n```php\n<?php $comments->listComments(); ?>\n```\n\n首次评论审核提示，在自定义评论代码的适当地方添加以下语句，否则将看不到审核提示语句。\n\n```php\n<?php if ('waiting' == $comments->status) { ?><span class=\"text-muted\">您的评论需管理员审核后才能显示！</span><?php } ?>\n```"},{"title":"Mix-Space 添加看板娘","slug":"mix-space-live2d","created":"2020-12-06T12:38:29.098Z","modified":"2020-12-06T13:11:29.300Z","content":"\n\n> Mix-Space第一个添加看板娘教程！\n\nLive2D看板娘来自[爆胎](https://www.itggg.cn)大佬\n\n进入*kami/pages/_document.tsx*\n\n在<link rel=\"manifest\" href=\"/manifest.json\" />后引入css文件\n\n```html\n<!--Live2D看板娘 By Wibus-->\n<link href=\"https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css\" rel=\"stylesheet\" />\n```\n\n左边看板娘是引入这个`<script src='//api.itggg.cn/liive2d/autoload.js'></script>`\n\n\n右边是引入这个`<script src='//api.itggg.cn/live2d/autoload.js'></script>`\n\n\n顺带把里面的静かな森全部改成自己的名字\n\n之后应用修改（看前面的章节）\n\n> 最后应该是这个样子的～\n\n![](https://gitee.com/wibus/blog-assets-goo/raw/master/asset-pic/mix-space-live2d.png)\n\n效果请看本博客～～\n\n> 多图预警！！！\n\n## 说明\n\n默认加载模型为 `PIO` 老婆\n![img](https://gitee.com/baotai/img/raw/master/img/photo.png)\n\n## 皮肤\n\n- 收集了 bilibili-22 全套皮肤\n- 收集了 bilibili-33 全套皮肤\n- 收集了 Pio 全套皮肤\n- 收集了 Tia 全套皮肤\n- 收集了 ShizukuTalk 2套皮肤\n- 收集了 HyperdimensionNeptunia全套皮肤\n- 收集了 KantaiCollection 1套皮肤\n\n\n\n## 模型展示\n![ ](https://gitee.com/baotai/img/raw/master/img/photo1.png)\n![ ](https://gitee.com/baotai/img/raw/master/img/photopio.png)\n![ ](https://gitee.com/baotai/img/raw/master/img/photo2.png)\n![ ](https://gitee.com/baotai/img/raw/master/img/photo3.png)\n![  ](https://gitee.com/baotai/img/raw/master/img/photo4.png)\n![ ](https://gitee.com/baotai/img/raw/master/img/photo5.png)\n![ ](https://gitee.com/baotai/img/raw/master/img/photo7.png)"}],"query":{"currentPage":1,"hasNext":false,"hasPrev":false,"size":28,"totalPage":1}},"__N_SSG":true}