{"ast":null,"code":"var __jsx = React.createElement;\nimport React from 'react';\nimport { observer as observerLite, Observer } from 'mobx-react-lite';\nconst hasSymbol = typeof Symbol === 'function' && Symbol.for; // Using react-is had some issues (and operates on elements, not on types), see #608 / #609\n\nconst ReactForwardRefSymbol = hasSymbol ? Symbol.for('react.forward_ref') : typeof React.forwardRef === 'function' && /*#__PURE__*/React.forwardRef(() => null)['$$typeof'];\nconst ReactMemoSymbol = hasSymbol ? Symbol.for('react.memo') : typeof React.memo === 'function' && /*#__PURE__*/React.memo(() => null)['$$typeof'];\n/**\n * Observer function / decorator\n */\n\nexport function observer(component) {\n  if (component['isMobxInjector'] === true) {\n    console.warn(\"Mobx observer: You are trying to use 'observer' on a component that already has 'inject'. Please apply 'observer' before applying 'inject'\");\n  }\n\n  if (ReactMemoSymbol && component['$$typeof'] === ReactMemoSymbol) {\n    throw new Error(\"Mobx observer: You are trying to use 'observer' on a function component wrapped in either another observer or 'React.memo'. The observer already applies 'React.memo' for you.\");\n  } // Unwrap forward refs into `<Observer>` component\n  // we need to unwrap the render, because it is the inner render that needs to be tracked,\n  // not the ForwardRef HoC\n\n\n  if (ReactForwardRefSymbol && component['$$typeof'] === ReactForwardRefSymbol) {\n    const baseRender = component['render'];\n    if (typeof baseRender !== 'function') throw new Error('render property of ForwardRef was not a function');\n    return /*#__PURE__*/React.forwardRef(function ObserverForwardRef() {\n      // eslint-disable-next-line prefer-rest-params\n      const args = arguments; // eslint-disable-next-line prefer-spread\n\n      return __jsx(Observer, null, () => baseRender.apply(undefined, args));\n    });\n  } // Function component\n\n\n  if (typeof component === 'function' && (!component.prototype || !component.prototype.render) && !component['isReactClass'] && !Object.prototype.isPrototypeOf.call(React.Component, component)) {\n    return observerLite(component);\n  }\n\n  return component;\n}","map":null,"metadata":{},"sourceType":"module"}