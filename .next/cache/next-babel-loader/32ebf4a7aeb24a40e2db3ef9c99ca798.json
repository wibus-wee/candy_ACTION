{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * @Author: Innei\n * @Date: 2020-09-05 09:33:40\n * @LastEditTime: 2020-09-05 19:09:37\n * @LastEditors: Innei\n * @FilePath: /candy/core/fetch.ts\n * @Coding with Love\n */\nimport dayjs from 'dayjs';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { resolve } from 'path';\nimport Collection from '../utils/collection';\nimport { isValidDate, UUID } from '../utils/utils';\nimport { readMarkdownFile } from './utils';\nconst curDir = process.cwd();\nconst rootDir = path.resolve(curDir, './_posts');\n\nclass Fetcher {\n  constructor() {\n    _defineProperty(this, \"articles\", new Collection());\n\n    _defineProperty(this, \"notes\", new Collection());\n\n    _defineProperty(this, \"pages\", new Collection());\n\n    if (false) {\n      throw new Error('must in Node.JS runtime environment');\n    }\n\n    this.init();\n  }\n\n  init() {\n    const posts = this.getAllPosts();\n    this.articles.clear();\n\n    for (const post of posts) {\n      this.articles.uniqueSet(post.slug, post);\n    }\n\n    const notes = this.getAllNotes();\n    this.notes.clear();\n\n    for (const note of notes) {\n      this.notes.set(note.nid.toString(), note);\n    }\n\n    const pages = this.getAllPages();\n    this.pages.clear();\n\n    for (const page of pages) {\n      this.pages.uniqueSet(page.slug.toString(), page);\n    }\n  }\n\n  resolvePostDir(type) {\n    return resolve(rootDir, type);\n  }\n\n  getAllFilesInDir(dir) {\n    return fs.readdirSync(dir).map(d => path.resolve(dir, d));\n  }\n\n  getAllPosts() {\n    const dir = this.resolvePostDir('articles');\n    const files = this.getAllFilesInDir(dir);\n    const all = [];\n\n    for (const p of files) {\n      try {\n        const {\n          content,\n          created,\n          metadata,\n          modified,\n          stat,\n          title\n        } = readMarkdownFile(p);\n        all.push({\n          title,\n          slug: metadata.slug || dayjs(stat.ctime).format('YYYY-MM-DD') || new UUID().uuid,\n          created: isValidDate(created) || stat.ctime.toISOString(),\n          modified: isValidDate(modified) || stat.mtime.toISOString(),\n          content\n        });\n      } catch {\n        continue;\n      }\n    }\n\n    return all.sort((b, a) => new Date(a.created).getTime() - new Date(b.created).getTime());\n  }\n\n  getPostBySlug(slug) {\n    return this.articles.get(slug);\n  }\n\n  getPostsByPager({\n    page = 1,\n    size = this.articles.size\n  } = {}) {\n    size = size || this.articles.size;\n    page = page || 1;\n    const totalPage = Math.ceil(this.articles.size / size);\n    const skip = (page - 1) * size;\n    const posts = this.articles.slice(skip, skip + size);\n    return {\n      posts,\n      query: {\n        currentPage: page,\n        hasNext: page + 1 <= totalPage,\n        hasPrev: page - 1 > 0,\n        size: size,\n        totalPage\n      }\n    };\n  }\n\n  getAllNotes() {\n    const dir = this.resolvePostDir('notes');\n    const paths = this.getAllFilesInDir(dir);\n    const all = [];\n    let i = 1;\n\n    for (const path of paths) {\n      try {\n        const {\n          content,\n          created,\n          metadata,\n          modified,\n          stat,\n          title\n        } = readMarkdownFile(path);\n        all.push({\n          title,\n          nid: i++,\n          created: isValidDate(created) || stat.ctime.toISOString(),\n          modified: isValidDate(modified) || stat.mtime.toISOString(),\n          content,\n          mood: metadata.mood || '',\n          weather: metadata.weather || '',\n          hasNext: false,\n          hasPrev: false\n        });\n      } catch {\n        continue;\n      }\n    }\n\n    return all.sort((a, b) => {\n      return new Date(a.created).getTime() - new Date(b.created).getTime();\n    }).map((i, index) => {\n      return _objectSpread(_objectSpread({}, i), {}, {\n        nid: index,\n        hasNext: index < all.length - 1,\n        hasPrev: index > 1\n      });\n    });\n  }\n\n  getAllPages() {\n    const dir = this.resolvePostDir('pages');\n    const paths = this.getAllFilesInDir(dir);\n    const all = [];\n\n    for (const path of paths) {\n      try {\n        const {\n          content,\n          created,\n          metadata,\n          modified,\n          stat,\n          title\n        } = readMarkdownFile(path);\n        all.push({\n          title,\n          subtitle: metadata.subtitle || '',\n          slug: metadata.slug || title,\n          created: isValidDate(created) || stat.ctime.toISOString(),\n          modified: isValidDate(modified) || stat.mtime.toISOString(),\n          content,\n          order: metadata.order\n        });\n      } catch {\n        continue;\n      }\n    } // asc\n\n\n    return all.sort((a, b) => a.order - b.order).map((n, i) => _objectSpread(_objectSpread({}, n), {}, {\n      order: i\n    }));\n  }\n\n}\n\nexport default new Fetcher();","map":null,"metadata":{},"sourceType":"module"}