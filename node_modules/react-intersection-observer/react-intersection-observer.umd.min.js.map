{"version":3,"file":"react-intersection-observer.umd.min.js","sources":["../node_modules/tiny-invariant/dist/tiny-invariant.esm.js","../src/intersection.ts","../src/InView.tsx","../src/useInView.tsx"],"sourcesContent":["var isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    throw new Error(prefix + \": \" + (message || ''));\n}\n\nexport default invariant;\n","import invariant from 'tiny-invariant'\nimport { ObserverInstance, ObserverInstanceCallback } from './index'\n\nconst INSTANCE_MAP: Map<Element, ObserverInstance> = new Map()\nconst OBSERVER_MAP: Map<string, IntersectionObserver> = new Map()\nconst ROOT_IDS: Map<Element, string> = new Map()\n\nlet consecutiveRootId = 0\n\n/**\n * Generate a unique ID for the root element\n * @param root\n */\nfunction getRootId(root?: Element | null) {\n  if (!root) return ''\n  if (ROOT_IDS.has(root)) return ROOT_IDS.get(root)\n  consecutiveRootId += 1\n  ROOT_IDS.set(root, consecutiveRootId.toString())\n  return ROOT_IDS.get(root) + '_'\n}\n\n/**\n * Monitor element, and trigger callback when element becomes inView\n * @param element {HTMLElement}\n * @param callback {Function} Called with inView\n * @param options {Object} InterSection observer options\n * @param options.threshold {Number} Number between 0 and 1, indicating how much of the element should be inView before triggering\n * @param options.root {HTMLElement}\n * @param options.rootMargin {String} The CSS margin to apply to the root element.\n */\nexport function observe(\n  element: Element,\n  callback: ObserverInstanceCallback,\n  options: IntersectionObserverInit = {},\n) {\n  // IntersectionObserver needs a threshold to trigger, so set it to 0 if it's not defined.\n  // Modify the options object, since it's used in the onChange handler.\n  if (!options.threshold) options.threshold = 0\n  const { root, rootMargin, threshold } = options\n  // Validate that the element is not being used in another <Observer />\n  invariant(\n    !INSTANCE_MAP.has(element),\n    \"react-intersection-observer: Trying to observe %s, but it's already being observed by another instance.\\nMake sure the `ref` is only used by a single <Observer /> instance.\\n\\n%s\",\n  )\n  /* istanbul ignore if */\n  if (!element) return\n  // Create a unique ID for this observer instance, based on the root, root margin and threshold.\n  // An observer with the same options can be reused, so lets use this fact\n  let observerId: string =\n    getRootId(root) +\n    (rootMargin\n      ? `${threshold.toString()}_${rootMargin}`\n      : threshold.toString())\n\n  let observerInstance = OBSERVER_MAP.get(observerId)\n  if (!observerInstance) {\n    observerInstance = new IntersectionObserver(onChange, options)\n    /* istanbul ignore else  */\n    if (observerId) OBSERVER_MAP.set(observerId, observerInstance)\n  }\n\n  const instance: ObserverInstance = {\n    callback,\n    element,\n    inView: false,\n    observerId,\n    observer: observerInstance,\n    // Make sure we have the thresholds value. It's undefined on a browser like Chrome 51.\n    thresholds:\n      observerInstance.thresholds ||\n      (Array.isArray(threshold) ? threshold : [threshold]),\n  }\n\n  INSTANCE_MAP.set(element, instance)\n  observerInstance.observe(element)\n\n  return instance\n}\n\n/**\n * Stop observing an element. If an element is removed from the DOM or otherwise destroyed,\n * make sure to call this method.\n * @param element {Element}\n */\nexport function unobserve(element: Element | null) {\n  if (!element) return\n  const instance = INSTANCE_MAP.get(element)\n\n  if (instance) {\n    const { observerId, observer } = instance\n    const { root } = observer\n\n    observer.unobserve(element)\n\n    // Check if we are still observing any elements with the same threshold.\n    let itemsLeft = false\n    // Check if we still have observers configured with the same root.\n    let rootObserved = false\n    /* istanbul ignore else  */\n    if (observerId) {\n      INSTANCE_MAP.forEach((item, key) => {\n        if (key !== element) {\n          if (item.observerId === observerId) {\n            itemsLeft = true\n            rootObserved = true\n          }\n          if (item.observer.root === root) {\n            rootObserved = true\n          }\n        }\n      })\n    }\n    if (!rootObserved && root) ROOT_IDS.delete(root)\n    if (observer && !itemsLeft) {\n      // No more elements to observe for threshold, disconnect observer\n      observer.disconnect()\n    }\n\n    // Remove reference to element\n    INSTANCE_MAP.delete(element)\n  }\n}\n\n/**\n * Destroy all IntersectionObservers currently connected\n **/\nexport function destroy() {\n  OBSERVER_MAP.forEach((observer) => {\n    observer.disconnect()\n  })\n\n  OBSERVER_MAP.clear()\n  INSTANCE_MAP.clear()\n  ROOT_IDS.clear()\n  consecutiveRootId = 0\n}\n\nfunction onChange(changes: IntersectionObserverEntry[]) {\n  changes.forEach((intersection) => {\n    const { isIntersecting, intersectionRatio, target } = intersection\n    const instance = INSTANCE_MAP.get(target)\n\n    // Firefox can report a negative intersectionRatio when scrolling.\n    /* istanbul ignore else */\n    if (instance && intersectionRatio >= 0) {\n      // If threshold is an array, check if any of them intersects. This just triggers the onChange event multiple times.\n      let inView = instance.thresholds.some((threshold) => {\n        return instance.inView\n          ? intersectionRatio > threshold\n          : intersectionRatio >= threshold\n      })\n\n      if (isIntersecting !== undefined) {\n        // If isIntersecting is defined, ensure that the element is actually intersecting.\n        // Otherwise it reports a threshold of 0\n        inView = inView && isIntersecting\n      }\n\n      instance.inView = inView\n      instance.callback(inView, intersection)\n    }\n  })\n}\n\nexport default {\n  observe,\n  unobserve,\n  destroy,\n}\n","import * as React from 'react'\nimport invariant from 'tiny-invariant'\nimport { observe, unobserve } from './intersection'\nimport { IntersectionObserverProps, PlainChildrenProps } from './index'\n\ntype State = {\n  inView: boolean\n  entry?: IntersectionObserverEntry\n}\n\nfunction isPlainChildren(\n  props: IntersectionObserverProps | PlainChildrenProps,\n): props is PlainChildrenProps {\n  return typeof props.children !== 'function'\n}\n\n/**\n * Monitors scroll, and triggers the children function with updated props\n *\n <InView>\n {({inView, ref}) => (\n   <h1 ref={ref}>{`${inView}`}</h1>\n )}\n </InView>\n */\nexport class InView extends React.Component<\n  IntersectionObserverProps | PlainChildrenProps,\n  State\n> {\n  static displayName = 'InView'\n  static defaultProps = {\n    threshold: 0,\n    triggerOnce: false,\n  }\n\n  state: State = {\n    inView: false,\n    entry: undefined,\n  }\n\n  componentDidMount() {\n    invariant(\n      this.node,\n      `react-intersection-observer: No DOM node found. Make sure you forward \"ref\" to the root DOM element you want to observe.`,\n    )\n  }\n\n  componentDidUpdate(prevProps: IntersectionObserverProps, prevState: State) {\n    // If a IntersectionObserver option changed, reinit the observer\n    if (\n      prevProps.rootMargin !== this.props.rootMargin ||\n      prevProps.root !== this.props.root ||\n      prevProps.threshold !== this.props.threshold ||\n      prevProps.skip !== this.props.skip\n    ) {\n      unobserve(this.node)\n      this.observeNode()\n    }\n\n    if (prevState.inView !== this.state.inView) {\n      if (this.state.inView && this.props.triggerOnce) {\n        unobserve(this.node)\n        this.node = null\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.node) {\n      unobserve(this.node)\n      this.node = null\n    }\n  }\n\n  node: Element | null = null\n\n  observeNode() {\n    if (!this.node || this.props.skip) return\n    const { threshold, root, rootMargin } = this.props\n    observe(this.node, this.handleChange, {\n      threshold,\n      root,\n      rootMargin,\n    })\n  }\n\n  handleNode = (node?: Element | null) => {\n    if (this.node) {\n      unobserve(this.node)\n      if (!node && !this.props.triggerOnce && !this.props.skip) {\n        this.setState({ inView: false, entry: undefined })\n      }\n    }\n    this.node = node ? node : null\n    this.observeNode()\n  }\n\n  handleChange = (inView: boolean, entry: IntersectionObserverEntry) => {\n    // Only trigger a state update if inView has changed.\n    // This prevents an unnecessary extra state update during mount, when the element stats outside the viewport\n    if (inView !== this.state.inView || inView) {\n      this.setState({ inView, entry })\n    }\n    if (this.props.onChange) {\n      // If the user is actively listening for onChange, always trigger it\n      this.props.onChange(inView, entry)\n    }\n  }\n\n  render() {\n    const { inView, entry } = this.state\n    if (!isPlainChildren(this.props)) {\n      return this.props.children({ inView, entry, ref: this.handleNode })\n    }\n\n    const {\n      children,\n      as,\n      tag,\n      triggerOnce,\n      threshold,\n      root,\n      rootMargin,\n      onChange,\n      ...props\n    } = this.props\n\n    return React.createElement(\n      as || tag || 'div',\n      { ref: this.handleNode, ...props },\n      children,\n    )\n  }\n}\n","/* eslint-disable react-hooks/exhaustive-deps */\nimport * as React from 'react'\nimport { observe, unobserve } from './intersection'\nimport { InViewHookResponse, IntersectionOptions } from './index'\nimport { useEffect } from 'react'\n\ntype State = {\n  inView: boolean\n  entry?: IntersectionObserverEntry\n}\n\nconst initialState: State = {\n  inView: false,\n  entry: undefined,\n}\n\nexport function useInView(\n  options: IntersectionOptions = {},\n): InViewHookResponse {\n  const ref = React.useRef<Element>()\n  const [state, setState] = React.useState<State>(initialState)\n\n  const setRef = React.useCallback(\n    (node) => {\n      if (ref.current) {\n        unobserve(ref.current)\n      }\n\n      if (options.skip) {\n        ref.current = undefined\n        return\n      }\n\n      if (node) {\n        observe(\n          node,\n          (inView, intersection) => {\n            setState({ inView, entry: intersection })\n\n            if (inView && options.triggerOnce) {\n              // If it should only trigger once, unobserve the element after it's inView\n              unobserve(node)\n            }\n          },\n          options,\n        )\n      }\n      // Store a reference to the node, so we can unobserve it later\n      ref.current = node\n    },\n    [\n      options.threshold,\n      options.root,\n      options.rootMargin,\n      options.triggerOnce,\n      options.skip,\n    ],\n  )\n\n  useEffect(() => {\n    if (\n      !ref.current &&\n      state !== initialState &&\n      !options.triggerOnce &&\n      !options.skip\n    ) {\n      // If we don't have a ref, then reset the state (unless the hook is set to only `triggerOnce` or `skip`)\n      // This ensures we correctly reflect the current state - If you aren't observing anything, then nothing is inView\n      setState(initialState)\n    }\n  })\n\n  return [setRef, state.inView, state.entry]\n}\n"],"names":["invariant","condition","message","Error","INSTANCE_MAP","Map","OBSERVER_MAP","ROOT_IDS","consecutiveRootId","observe","element","callback","options","threshold","root","rootMargin","has","observerId","get","set","toString","getRootId","observerInstance","IntersectionObserver","onChange","instance","inView","observer","thresholds","Array","isArray","unobserve","itemsLeft","rootObserved","forEach","item","key","disconnect","changes","intersection","isIntersecting","intersectionRatio","target","some","undefined","InView","entry","node","_this","props","triggerOnce","skip","setState","observeNode","state","componentDidMount","this","componentDidUpdate","prevProps","prevState","componentWillUnmount","handleChange","render","children","isPlainChildren","ref","handleNode","as","tag","React","initialState","setRef","current","useEffect"],"mappings":"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"}