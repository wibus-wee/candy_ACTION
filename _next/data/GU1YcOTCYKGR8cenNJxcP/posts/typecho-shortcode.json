{"pageProps":{"title":"Typecho实现短代码功能","slug":"typecho-shortcode","created":"2020-12-27T00:55:56.054Z","modified":"2020-12-27T06:57:23.417Z","content":"\n\n这里用回复可见做🌰\n\n## 替换文章输出\n\n将post.php中的`<?php $this->content(); ?>`换成\n```php\n<?php\n$db = Typecho_Db::get();\n$sql = $db->select()->from('table.comments')\n    ->where('cid = ?',$this->cid)\n    ->where('mail = ?', $this->remember('mail',true))\n    ->where('status = ?', 'approved')\n//只有通过审核的评论才能看回复可见内容\n    ->limit(1);\n$result = $db->fetchAll($sql);\n\nif($this->user->hasLogin() || $result) {\n    $content = preg_replace(\"/\\[hide\\](.*?)\\[\\/hide\\]/sm\",'<div class=\"reply2view\">$1</div>',$this->content);\n}\nelse{\n    $content = preg_replace(\"/\\[hide\\](.*?)\\[\\/hide\\]/sm\",'<div class=\"reply2view\">此处内容需要评论回复后方可阅读。</div>',$this->content);\n}\necho $content \n\n?>\n```\n\n当然你也可以像我那样，新建一个类，使用`<?php YourClass::Name(); ?>`\n\n```php\nclass Content{\n\n    /**\n     * 替换文章输出实现短代码功能\n     * Author：Wibus\n     * Date：12-27\n     */\n\n    function echoSomeFunny(){\n    \n            $db = Typecho_Db::get();\n        $sql = $db->select()->from('table.comments')\n            ->where('cid = ?',$this->cid)\n            ->where('mail = ?', $this->remember('mail',true))\n            ->where('status = ?', 'approved')\n        //只有通过审核的评论才能看回复可见内容\n            ->limit(1);\n        $result = $db->fetchAll($sql);\n\n        if($this->user->hasLogin() || $result) {\n            $content = preg_replace(\"/\\[hide\\](.*?)\\[\\/hide\\]/sm\",'<div class=\"reply2view\">$1</div>',$this->content);\n        }\n        else{\n            $content = preg_replace(\"/\\[hide\\](.*?)\\[\\/hide\\]/sm\",'<div class=\"reply2view\">此处内容需要评论回复后方可阅读。</div>',$this->content);\n        }\n        echo $content;\n    }\n}\n```\n\n那么就是将post.php中的`<?php $this->content(); ?>`换成`<?php Content::echoSomeFunny();`\n\n## 解决feed暴露\n\n解决缩略内容和feed暴露问题。\n\n在functions.php中加入如下代码即可\n```php\nTypecho_Plugin::factory('Widget_Abstract_Contents')->excerptEx = array('myyodux','one');\nTypecho_Plugin::factory('Widget_Abstract_Contents')->contentEx = array('myyodux','one');\nclass myyodux {\n    public static function one($con,$obj,$text)\n    {\n      $text = empty($text)?$con:$text;\n      if(!$obj->is('single')){\n      $text = preg_replace(\"/\\[hide\\](.*?)\\[\\/hide\\]/sm\",'',$text);\n      }\n      \n               return $text;\n}\n}\n```\n\n就是用插件接口，在缩略内容输出之前，隐藏掉或者替换掉回复可见内容，同时使用if判断，来针对非single页面进行隐藏。\n\n## 使用方法\n\n在写文章需要隐藏部分内容时用以下写法\n\n`[hide]要隐藏的内容[/hide]`\n\n> 不过这个方法会有一个问题：你只能有一个短代码，所以需要找到其他的方法\n\n---\n\n## 后续解决\n\n后来翻找了一下Wordpress程序以及handsome主题，解决了问题\n\n```php\n\n    /**\n     * 短代码模块\n     * Author：Wibus\n     * 参照项目：Wordpress handsome\n     * Date：2020-12-27\n     * 相关function：\n     * get_shortcode_regex，shortcode_parse_atts，get_shortcode_atts_regex，get_markdown_regex，scodeParseCallback，parseContentPublic，postContent，postContentHtml\n     */\n\n    /**\n     * 获取匹配短代码的正则表达式\n     * Date: 2020-12-27\n     * @param null $tagnames\n     * @return string\n     * @link https://github.com/WordPress/WordPress/blob/master/wp-includes/shortcodes.php#L254\n     */\n    public static function get_shortcode_regex($tagnames = null)\n    {\n        global $shortcode_tags;\n        if (empty($tagnames)) {\n            $tagnames = array_keys($shortcode_tags);\n        }\n        $tagregexp = join('|', array_map('preg_quote', $tagnames));\n        // WARNING! Do not change this regex without changing do_shortcode_tag() and strip_shortcode_tag()\n        // Also, see shortcode_unautop() and shortcode.js.\n        // phpcs:disable Squiz.Strings.ConcatenationSpacing.PaddingFound -- don't remove regex indentation\n        return\n            '\\\\['                                // Opening bracket\n            . '(\\\\[?)'                           // 1: Optional second opening bracket for escaping shortcodes: [[tag]]\n            . \"($tagregexp)\"                     // 2: Shortcode name\n            . '(?![\\\\w-])'                       // Not followed by word character or hyphen\n            . '('                                // 3: Unroll the loop: Inside the opening shortcode tag\n            . '[^\\\\]\\\\/]*'                   // Not a closing bracket or forward slash\n            . '(?:'\n            . '\\\\/(?!\\\\])'               // A forward slash not followed by a closing bracket\n            . '[^\\\\]\\\\/]*'               // Not a closing bracket or forward slash\n            . ')*?'\n            . ')'\n            . '(?:'\n            . '(\\\\/)'                        // 4: Self closing tag ...\n            . '\\\\]'                          // ... and closing bracket\n            . '|'\n            . '\\\\]'                          // Closing bracket\n            . '(?:'\n            . '('                        // 5: Unroll the loop: Optionally, anything between the opening and closing shortcode tags\n            . '[^\\\\[]*+'             // Not an opening bracket\n            . '(?:'\n            . '\\\\[(?!\\\\/\\\\2\\\\])' // An opening bracket not followed by the closing shortcode tag\n            . '[^\\\\[]*+'         // Not an opening bracket\n            . ')*+'\n            . ')'\n            . '\\\\[\\\\/\\\\2\\\\]'             // Closing shortcode tag\n            . ')?'\n            . ')'\n            . '(\\\\]?)';                          // 6: Optional second closing brocket for escaping shortcodes: [[tag]]\n        // phpcs:enable\n    }\n    /**\n     * 获取短代码属性数组\n     * Date: 2020-12-27\n     * @param $text\n     * @return array|string\n     * @link https://github.com/WordPress/WordPress/blob/master/wp-includes/shortcodes.php#L508\n     */\n    public static function shortcode_parse_atts($text)\n    {\n        $atts = array();\n        $pattern = self::get_shortcode_atts_regex();\n        $text = preg_replace(\"/[\\x{00a0}\\x{200b}]+/u\", ' ', $text);\n        if (preg_match_all($pattern, $text, $match, PREG_SET_ORDER)) {\n            foreach ($match as $m) {\n                if (!empty($m[1])) {\n                    $atts[strtolower($m[1])] = stripcslashes($m[2]);\n                } elseif (!empty($m[3])) {\n                    $atts[strtolower($m[3])] = stripcslashes($m[4]);\n                } elseif (!empty($m[5])) {\n                    $atts[strtolower($m[5])] = stripcslashes($m[6]);\n                } elseif (isset($m[7]) && strlen($m[7])) {\n                    $atts[] = stripcslashes($m[7]);\n                } elseif (isset($m[8]) && strlen($m[8])) {\n                    $atts[] = stripcslashes($m[8]);\n                } elseif (isset($m[9])) {\n                    $atts[] = stripcslashes($m[9]);\n                }\n            }\n            // Reject any unclosed HTML elements\n            foreach ($atts as &$value) {\n                if (false !== strpos($value, '<')) {\n                    if (1 !== preg_match('/^[^<]*+(?:<[^>]*+>[^<]*+)*+$/', $value)) {\n                        $value = '';\n                    }\n                }\n            }\n        } else {\n            $atts = ltrim($text);\n        }\n        return $atts;\n    }\n\n    /**\n     * Retrieve the shortcode attributes regex.\n     * Date: 2020-12-27\n     * @return string The shortcode attribute regular expression\n     * @since 4.4.0\n     *\n     */\n    public static function get_shortcode_atts_regex()\n    {\n        return '/([\\w-]+)\\s*=\\s*\"([^\"]*)\"(?:\\s|$)|([\\w-]+)\\s*=\\s*\\'([^\\']*)\\'(?:\\s|$)|([\\w-]+)\\s*=\\s*([^\\s\\'\"]+)(?:\\s|$)|\"([^\"]*)\"(?:\\s|$)|\\'([^\\']*)\\'(?:\\s|$)|(\\S+)(?:\\s|$)/';\n    }\n\n    public static function get_markdown_regex($tagName = '?')\n    {\n        return '\\\\' . $tagName . '&gt; (.*)(\\n\\n)?';\n\n    }\n\n    /**\n     * 短代码解析正则替换回调函数\n     * Date: 2020-12-27\n     * Style: Super_Code\n     * @param $matches\n     * @return bool|string\n     */\n    public static function scodeParseCallback($matches)\n    {\n        // 不解析类似 [[player]] 双重括号的代码\n        if ($matches[1] == '[' && $matches[6] == ']') {\n            return substr($matches[0], 1, -1);\n        }\n        //[scode type=\"share\"]这是灰色的短代码框，常用来引用资料什么的[/scode]\n        $attr = htmlspecialchars_decode($matches[3]);//还原转义前的参数列表\n        $attrs = self::shortcode_parse_atts($attr);//获取短代码的参数\n        $type = \"info\";\n        switch (@$attrs['type']) {\n            case 'yellow':\n                $type = \"Scode-Yellow\";\n                break;\n            case 'red':\n                $type = \"Scode-Red\";\n                break;\n            case 'lblue':\n                $type = \"Scode-Blue\";\n                break;\n            case 'green':\n                $type = \"Scode-Green\";\n                break;\n            case 'share':\n                $type = \"Scode-zise\";\n                break;\n            case 'pink':\n                $type = \"Scode-Pink\";\n                break;\n            case 'pink-pro':\n                $type = \"Scode-Pink-Pro\";\n                break;\n            case 'black':\n                $type = \"Scode-Black\";\n                break;\n            case 'mhz':\n                $type = \"Scode-mhz\";\n                break;\n            case 'xgh':\n                $type = \"Scode-xgh\";\n                break;\n            case 'tkzj':\n                $type = \"Scode-tkzj\";\n                break;\n            case 'xyz':\n                $type = \"Scode-xyz\";\n                break;\n            case 'gll':\n                $type = \"Scode-gll\";\n                break;\n            case 'xty':\n                $type = \"Scode-xty\";\n                break;\n            case 'Shadow':\n                $type = \"Shadow\";\n                break;\n            \n        }\n        return '<div class=\" ' . $type . '\">'.\"\\n\\n\" . $matches[5] . \"\\n\".'</div>';\n    }\n\n    /**\n     * 文章解析函数\n     * Date: 2020-12-27\n     * @param $content\n     * @return null|string|string[]\n     */\n    public static function parseContentPublic($content)\n    {\n        //解析短代码功能\n        if (strpos($content, '[scode') !== false) {//提高效率，避免每篇文章都要解析\n            $pattern = self::get_shortcode_regex(array('scode'));\n            $content = preg_replace_callback(\"/$pattern/\", array('Content', 'scodeParseCallback'),\n                $content);\n        }\n        \n        return $content;\n    }\n\n    /**\n     * 替换+输出文章内容\n     * Date: 2020-12-27\n     *\n     * @param $obj\n     * @param $status\n     * @param string $way\n     * @return string\n     */\n    public static function postContent($obj, $status, $way = \"origin\")\n    {\n        if ($way == \"origin\") {\n            $content = $obj->content;\n        } else {\n            $content = $obj->content;\n\n            $content = Content::parseContentPublic($content);\n        }\n        return trim($content);\n    }\n\n    public static function postContentHtml($obj, $status)\n    {\n\n        //$way = \"origin\";\n        \n        $content = Content::postContent($obj, $status, $way);\n        \n        echo $content;\n\n    }\n```\n\n其中，get_shortcode_regex，shortcode_parse_atts，get_shortcode_atts_regex，get_markdown_regex都是wp里的东西\n\n剩下的就是用来替换的了，注释应该都写的挺清楚的了吧？\n\n### 调用方法\n\n将post.php里的`<?php $this->content(); ?>`替换为`<?php Content::postContentHtml($this,$this->user->hasLogin()); ?>·`"},"__N_SSG":true}