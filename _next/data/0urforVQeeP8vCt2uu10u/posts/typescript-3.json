{"pageProps":{"title":"一起入手TypeScript（三）","slug":"typescript-3","created":"2021-01-02T05:13:43.268Z","modified":"2021-01-02T09:48:57.625Z","content":"\n\n## 7 TypeScript 元组的使用和类型约束\n\n元组是TS特有的一个概念，JavaScript并没有这个概念\n\n### 7.1 元组的基本使用\n\n我们先来看一个例子\n\n```ts\nconst xiaojiejie = [\"Qwq\", \"NoJob\", 28];\n```\n\n这时候把鼠标放到xiaojiejie变量上面，可以看出`推断`出来的类型。我们就用`类型注解`的形式给他作一个注解\n\n```ts\nconst zhujie_xiaojiejie : (number | string)[] = [\"Qwq\", \"NoJob\", 28];\n```\n\n这个时候你已经添加了`类型注解`，但是在下面的代码当中会有一个`小细节问题`\n\n```ts\nconst Badxiaojiejie: (number | string)[] = [\"Qwq\", 28, \"NoJob\"];\n```\n\n我们只是把数组的位置调换了一下，但是`TS`并不能发现这个问题，所以我们需要一个更强大的类型，来解决，所以，这就是`元组`\n\n元组和数组比较类似，但是类型注解的时候有点不一样\n\n```ts\nconst Shuzu_xiaojiejie: [string, string, number] = [\"Qwq\", \"NoJob\", 28];\n```\n\n这个样子我们就把每个类型的位置都固定住了，这就叫做元组\n\n#### 7.2 元组的使用\n\n我们假设有这样子的一组数据\n\n```ts\n\"dajiao\", \"teacher\", 28;\n\"liuying\", \"teacher\", 18;\n\"cuihua\", \"teacher\", 25;\n```\n\n如果是这个样子的话，我们可以看到前两个都是字符串，最后一个是常数。\n\n```ts\nconst xiaojiejies: [string, string, number][] = [\n  [\"dajiao\", \"teacher\", 28],\n  [\"liuying\", \"teacher\", 18],\n  [\"cuihua\", \"teacher\", 25],\n];\n```\n\n你要搞清楚元组和数组的区别，在理解后能在项目中适当的时候使用不同的类型。\n\n### Demo7.ts\n\n```ts\n/**\n * Demo7.ts\n * TypeScript 元组的使用和类型约束\n * @date 2021-1-2\n * @author Wibus\n */\n\n//元组是TS特有的一个概念，JavaScript并没有这个概念\n\n// 1 元组的基本使用\nconst xiaojiejie = [\"Qwq\", \"NoJob\", 28];\n// 把上面的进行类型注解\nconst zhujie_xiaojiejie : (number | string)[] = [\"Qwq\", \"NoJob\", 28];\n// 这个时候你已经添加了类型注解，但是在下面的代码当中会有一个小细节问题\nconst Badxiaojiejie: (number | string)[] = [\"Qwq\", 28, \"NoJob\"];\n//我们只是把数组的位置调换了一下，但是TS并不能发现这个问题，所以我们需要一个更强大的类型，来解决，所以，这就是元组\nconst Shuzu_xiaojiejie: [string, string, number] = [\"Qwq\", \"NoJob\", 28];\n// 这个时候我们就已经把每一个类型都固定住了\n\n// 2 元组的使用\n\n// 得到的数据源是这样子的：\n// \"dajiao\", \"teacher\", 28;\n// \"liuying\", \"teacher\", 18;\n// \"cuihua\", \"teacher\", 25;\n\nconst xiaojiejies: [string, string, number][] = [\n  [\"dajiao\", \"teacher\", 28],\n  [\"liuying\", \"teacher\", 18],\n  [\"cuihua\", \"teacher\", 25],\n];\n\n// 你要搞清楚元组和数组的区别，在理解后能在项目中适当的时候使用不同的类型。\n```\n\n## 8 TypeScript 的 interface接口\n\nTypeScript的接口。就是用来规范类型的\n\n### 8.1 Interface 接口初步了解\n\n我们要作一个简历的自动筛选程序，很简单。年龄小于 25 岁，胸围大于 90 公分的，可以进入面试环节。我们最开始的写法是这样的\n\n```ts\nconst screenresume = (name: string, age: number, bust: number) => {\n    age < 24 && bust >= 90 && console.log(name + \"Pass\");\n    age > 24 || (bust < 90 && console.log(name + \"Can't Pass\"));\n};\n\nscreenresume(\"Wibus\", 14, 90);\n```\n\n好像还不错，我们再加上个查看简历的功能，于是你的代码是这样\n\n```ts\nconst getResume = (name: string, age: number, bust: number) => {\n    console.log(name+ \"age: \" + age);\n    console.log(name+ \"Bust: \" + bust);\n}\ngetResume(\"Wibus\", 14, 90);\n```\n\n但是这个时候会发现，有很多东西重复了，程序开发中一直强调“代码重用”，两个方法用的类型注解一样，需要作个统一的约束。大上节课我们学了一个`类型别名`的知识可以解决代码重复的问题，这节课我们就学习一个更常用的语法`接口`（Interface）.\n\n我们可以把这两个重复进行类型注解，定义成统一的接口。代码如下\n\n```ts\ninterface Girl {\n  name: string;\n  age: number;\n  bust: number;\n}\n```\n\n有了这个接口后我们程序也要做一些修改\n\n```ts\nconst screenresume2 = (girl: Girl) => {\n    girl.age < 24 && girl.bust >= 90 && console.log(girl.name + \"Pass\");\n    girl.age > 24 || (girl.bust < 90 && console.log(girl.name + \"Can't Pass\"));\n};\n\nconst getResume2 = (girl: Girl) => {\n    console.log(girl.name+ \"age: \" + girl.age);\n    console.log(girl.name+ \"Bust: \" + girl.bust);\n};\n\nconst girl = {\n    name: \"Wibus\",\n    age: 14,\n    bust: 94,\n};\n\nscreenresume2(girl);\ngetResume2(girl);\n```\n这样就更像是面向对象编程了,以后再用到同样的接口也不怕了，直接使用girl就可以了。\n\n### 8.2 接口和类型别名的区别\n\n现在我们学了`接口`，也学过了`类型别名`，这两个语法和用处好像一样, 确实用起来基本一样，但是也有少许的不同。\n\n> 类型别名可以直接给类型，比如string，而接口必须代表对象。\n\n比如我们的类型别名可以写出下面的代码：\n```ts\ntype Girl1 = stirng;\n```\n但是接口就不能这样写，它必须代表的是一个对象，也就是说，你初始化`girl`的时候，必须写出下面的形式.\n```ts\nconst girl = {\n  name: \"大脚\",\n  age: 18,\n  bust: 94,\n};\n```\n\n### 8.3 接口非必选值定义\n\n我们要求尽量能看到小姐姐的腰围，但是不作强制要求，就是`可选值`。那接口如何定义？`typeScript`已经为我们准备好了相应的办法，就是在 *:* 号前加一个 *?*\n\n比如把Girl的接口写成这样。\n\n```ts\ninterface Girl2 {\n  name: string;\n  age: number;\n  bust: number;\n  waistline?: number; // 非必选值\n}\n```\n\n再修改一下getResume方法，写成这样。\n\n```ts\nconst getResume3 = (girl: Girl2) => {\n  console.log(girl.name + \"年龄是：\" + girl.age);\n  console.log(girl.name + \"胸围是：\" + girl.bust);\n  girl.waistline && console.log(girl.name + \"腰围是：\" + girl.waistline);\n};\n```\n\n这时候在定义`girl对象`的时候，就可以写`saistline`（腰围），也可以不写了。\n\n### Demo8.ts\n\n```ts\n/**\n * Demo8.ts\n * TypeScript 的 interface 接口\n * @date 2021-1-2\n * @author Wibus\n * interface东西比较多，分两次讲述\n */\n\n// 1 interface 接口初步了解\n\n// 1.1 简历工具\nconst screenresume = (name: string, age: number, bust: number) => {\n    age < 24 && bust >= 90 && console.log(name + \"Pass\");\n    age > 24 || (bust < 90 && console.log(name + \"Can't Pass\"));\n};\n\nscreenresume(\"Wibus\", 14, 90);\n// ts-node demo8.ts\n// 进入面试\n\n\nconst getResume = (name: string, age: number, bust: number) => {\n    console.log(name+ \"age: \" + age);\n    console.log(name+ \"Bust: \" + bust);\n}\n\n// 但是似乎name: string, age: number, bust: number一直在出现\n// 为了避免啊代码重用，我们可以使用接口\n\ninterface Girl {\n    name: string;\n    age: number;\n    bust: number;\n}\n// 于是我们就需要修改一点程序\nconst screenresume2 = (girl: Girl) => {\n    girl.age < 24 && girl.bust >= 90 && console.log(girl.name + \"Pass\");\n    girl.age > 24 || (girl.bust < 90 && console.log(girl.name + \"Can't Pass\"));\n};\n\nconst getResume2 = (girl: Girl) => {\n    console.log(girl.name+ \"age: \" + girl.age);\n    console.log(girl.name+ \"Bust: \" + girl.bust);\n};\n\nconst girl = {\n    name: \"Wibus\",\n    age: 14,\n    bust: 94,\n};\n\nscreenresume2(girl);\ngetResume2(girl);\n\n// 2 接口和类型别名的区别\n\ntype Girl1 = string;\n\nconst girl1 = {\n    name: \"Wibus\",\n    age: 14,\n    bust: 94 \n};\n\n// 3 接口非必选值定义\n\ninterface Girl2 {\n  name: string;\n  age: number;\n  bust: number;\n  waistline?: number; // 非必选值\n}\n\nconst getResume3 = (girl: Girl2) => {\n  console.log(girl.name + \"年龄是：\" + girl.age);\n  console.log(girl.name + \"胸围是：\" + girl.bust);\n  girl.waistline && console.log(girl.name + \"腰围是：\" + girl.waistline);\n};\n\n//这时候在定义girl对象的时候，就可以写saistline（腰围），也可以不写了。\n```\n\n## 9 TypeScript 的 interface 接口 2\n\n我们接着继续讲接口，接口部分的内容还是比较多的\n\n### 9.1 允许加入任意值\n\n简历一般是有自由发挥的空间的，所以这时候需要一些任意值，就是自己愿意写什么就写什么。这时候interface接口也是支持的。\n\n```ts\ninterface Girl1 {\n    name: string;\n    age: number;\n    bust: number;\n    waistline?: number;\n    [propname: string]: any; //属性的名字是字符串类型，属性的值可以是任何类型。\n  }\n```\n\n`propname` 你可以随意改成其他的名字～\n\n这时候我们在对象里给一个性别\n\n```ts\nconst girl = {\n    name: \"大脚\",\n    age: 18,\n    bust: 94,\n    waistline: 21,\n    sex: \"女\",\n  };\n```\n\n再修改一下代码，就没有错误了。\n\n```ts\nconst getResume = (girl: Girl1) => {\n    console.log(girl.name + \"年龄是：\" + girl.age);\n    console.log(girl.name + \"胸围是：\" + girl.bust);\n    girl.waistline && console.log(girl.name + \"腰围是：\" + girl.waistline);\n    girl.sex && console.log(girl.name + \"性别是：\" + girl.sex);\n  };\n```\n\n这时候我们的程序是不报错的，但是如果我们去掉刚才的设置，就会报错。\n\n```ts\n[propname:string]:any;  //去掉\n```\n\n### 9.2 接口里的方法\n\n接口里不仅可以存属性，还可以存方法，比如这时候有个`say()`方法，返回值是`string`类型。这时候你就不要再想成简历了，你需要更面向对象化的编程，想象成一个人。\n\n```ts\ninterface Girl2 {\n    name: string;\n    age: number;\n    bust: number;\n    waistline?: number;\n    [propname: string]: any;\n    say(): string;\n}\n```\n\n加上这个`say()`方法后，程序马上就会报错，因为我们对象里没有` say `方法。那我们就要给对象一个` say `方法\n\n```ts\nconst girl2 = {\n  name: \"Wibus\",\n  age: 14,\n  bust: 94,\n  waistline: 21,\n  sex: \"女\",\n  say() {\n    return \"欢迎光临 ，红浪漫洗浴！！\";\n  },\n};\n```\n\n### 9.3 接口和类的约束\n\n` JavaScript `从ES6里是有类这个概念的，类可以和接口很好的结合\n\n```ts\nclass XiaoJieJie implements Girl {}\n```\n\n这时候类会直接报错，所以我们需要把这个类写的完全点。\n\n```ts\nclass xiaojiejie implements Girl2 {\n    name: \"大脚\";\n    age: 18;\n    bust: 94;\n    waistline: 21;\n    sex: \"女\";\n    say() {\n      return \"欢迎光临 ，红浪漫洗浴！！\";\n    };\n};\n```\n\n### 9.4 接口的继承\n\n接口也可以用于继承的，比如你新写一个`Teacher`接口，继承于`Person`接口。\n\n```ts\ninterface Teacher extends Girl2{\n    teach(): string;\n}\n```\n\n比如这时候，只看` Teacher `级别的简历，那我们需要修改`getResume()`方法。\n\n```ts\nconst getResume2 = (girl2: Teacher) => {\n    console.log(girl2.name + \"年龄是：\" + girl2.age);\n    console.log(girl2.name + \"胸围是：\" + girl2.bust);\n    girl2.waistline && console.log(girl2.name + \"腰围是：\" + girl2.waistline);\n    girl2.sex && console.log(girl2.name + \"性别是：\" + girl2.sex);\n};\ngetResume2(girl2);\n```\n\n修改后，你就会发现下面我们调用`getResume2()`方法的地方报错了,因为这时候传的值必须有`Teach`方法，修改`girl`对象，增加`teach（）`方法，这时候就不会报错了。\n\n```ts\nconst girl2 = {\n  name: \"Wibus\",\n  age: 14,\n  bust: 94,\n  waistline: 21,\n  sex: \"女\",\n  say() {\n    return \"欢迎光临 ，红浪漫洗浴！！\";\n  },\n    teach() {\n    return \"我是一个老师\";\n  },\n};\n```\n\n关于接口的知识就讲到这里吧，这基本包含了接口 80%的知识\n\n## Demo9.ts\n\n```ts\n/**\n * Demo9.ts\n * TypeScript 的 interface 接口 2\n * @date 2021-1-2\n * @author Wibus\n */\n\n // 1 允许加入任意值\n//  简历一般是有自由发挥的空间的，所以这时候需要一些任意值，就是自己愿意写什么就写什么。这时候interface接口也是支持的。\ninterface Girl1 {\n    name: string;\n    age: number;\n    bust: number;\n    waistline?: number;\n    [name: string]: any; //属性的名字是字符串类型，属性的值可以是任何类型。\n  }\n// 这时候我们在对象里给一个性别\nconst girl = {\n    name: \"大脚\",\n    age: 18,\n    bust: 94,\n    waistline: 21,\n    sex: \"女\",\n  };\n//   再修改一下代码，就没有错误了。\nconst getResume = (girl: Girl1) => {\n    console.log(girl.name + \"年龄是：\" + girl.age);\n    console.log(girl.name + \"胸围是：\" + girl.bust);\n    girl.waistline && console.log(girl.name + \"腰围是：\" + girl.waistline);\n    girl.sex && console.log(girl.name + \"性别是：\" + girl.sex);\n  };\n// 这时候我们的程序是不报错的，但是如果我们去掉刚才的设置，就会报错。\n\n// 2 接口里的方法\n// 接口里不仅可以存属性，还可以存方法，比如这时候有个say()方法，返回值是string类型。这时候你就不要再想成简历了，你需要更面向对象化的编程，想象成一个人。\n\ninterface Girl2 {\n    name: string;\n    age: number;\n    bust: number;\n    waistline?: number;\n    [propname: string]: any;\n    say(): string;\n  }\n// 加上这个say()方法后，程序马上就会报错，因为我们对象里没有 say 方法。那我们就要给对象一个 say 方法\n\nconst girl2 = {\n  name: \"Wibus\",\n  age: 14,\n  bust: 94,\n  waistline: 21,\n  sex: \"女\",\n  say() {\n    return \"欢迎光临 ，红浪漫洗浴！！\";\n  },\n    teach() {\n    return \"我是一个老师\";\n  },\n};\n\n// 3 接口和类的约束\n// 类和接口能有很好的结合\n\nclass xiaojiejie implements Girl2 {\n    name: \"大脚\";\n    age: 18;\n    bust: 94;\n    waistline: 21;\n    sex: \"女\";\n    say() {\n      return \"欢迎光临 ，红浪漫洗浴！！\";\n    };\n};\n\n// 4 接口的继承\n// 接口也可以用于继承的，比如你新写一个Teacher接口，继承于Person接口。\n\ninterface Teacher extends Girl2{\n    teach(): string;\n}\n\n// 比如这时候，只看 Teacher 级别的简历，那我们需要修改getResume()方法。\nconst getResume2 = (girl2: Teacher) => {\n    console.log(girl2.name + \"年龄是：\" + girl2.age);\n    console.log(girl2.name + \"胸围是：\" + girl2.bust);\n    girl2.waistline && console.log(girl2.name + \"腰围是：\" + girl2.waistline);\n    girl2.sex && console.log(girl2.name + \"性别是：\" + girl2.sex);\n  };\n  \ngetResume2(girl2);\n```"},"__N_SSG":true}